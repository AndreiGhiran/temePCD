r the platform's
       * default character set. The {@linkplain java.nio.charset.CharsetDecoder}
       * class should be used when more control over the decoding process is
       * required.
       *
       * @return String decoded from the buffer's contents.
       * @since  JDK1.1
       */
      ByteArrayOutputStream.prototype.toString_void = function () {
          return new String(this.buf /*, 0, this.count*/).toString();
      };
      /**
       * Converts the buffer's contents into a string by decoding the bytes using
       * the specified {@link java.nio.charset.Charset charsetName}. The length of
       * the new <tt>String</tt> is a function of the charset, and hence may not be
       * equal to the length of the byte array.
       *
       * <p> This method always replaces malformed-input and unmappable-character
       * sequences with this charset's default replacement string. The {@link
       * java.nio.charset.CharsetDecoder} class should be used when more control
       * over the decoding process is required.
       *
       * @param  charsetName  the name of a supported
       *              {@linkplain java.nio.charset.Charset </code>charset<code>}
       * @return String decoded from the buffer's contents.
       * @exception  UnsupportedEncodingException
       *             If the named charset is not supported
       * @since   JDK1.1
       */
      ByteArrayOutputStream.prototype.toString_string = function (charsetName) {
          return new String(this.buf /*, 0, this.count, charsetName*/).toString();
      };
      /**
       * Creates a newly allocated string. Its size is the current size of
       * the output stream and the valid contents of the buffer have been
       * copied into it. Each character <i>c</i> in the resulting string is
       * constructed from the corresponding element <i>b</i> in the byte
       * array such that:
       * <blockquote><pre>
       *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
       * </pre></blockquote>
       *
       * @deprecated This method does not properly convert bytes into characters.
       * As of JDK&nbsp;1.1, the preferred way to do this is via the
       * <code>toString(String enc)</code> method, which takes an encoding-name
       * argument, or the <code>toString()</code> method, which uses the
       * platform's default character encoding.
       *
       * @param      hibyte    the high byte of each resulting Unicode character.
       * @return     the current contents of the output stream, as a string.
       * @see        java.io.ByteArrayOutputStream#size()
       * @see        java.io.ByteArrayOutputStream#toString(String)
       * @see        java.io.ByteArrayOutputStream#toString()
       */
      // @Deprecated
      ByteArrayOutputStream.prototype.toString_number = function (hibyte) {
          return new String(this.buf /*, hibyte, 0, this.count*/).toString();
      };
      /**
       * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
       * this class can be called after the stream has been closed without
       * generating an <tt>IOException</tt>.
       * <p>
       *
       * @throws IOException
       */
      ByteArrayOutputStream.prototype.close = function () {
      };
      return ByteArrayOutputStream;
  }(OutputStream));

  /*
   * Copyright 2009 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /*private*/ var Mode$2;
  (function (Mode) {
      Mode[Mode["ALPHA"] = 0] = "ALPHA";
      Mode[Mode["LOWER"] = 1] = "LOWER";
      Mode[Mode["MIXED"] = 2] = "MIXED";
      Mode[Mode["PUNCT"] = 3] = "PUNCT";
      Mode[Mode["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
      Mode[Mode["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
  })(Mode$2 || (Mode$2 = {}));
  /**
   * Indirectly access the global BigInt constructor, it
   * allows browsers that doesn't support BigInt to run
   * the library without breaking due to "undefined BigInt"
   * errors.
   */
  function getBigIntConstructor() {
      if (typeof window !== 'undefined') {
          return window['BigInt'] || null;
      }
      if (typeof global !== 'undefined') {
          return global['BigInt'] || null;
      }
      if (typeof self !== 'undefined') {
          return self['BigInt'] || null;
      }
      throw new Error('Can\'t search globals for BigInt!');
  }
  /**
   * Used to store the BigInt constructor.
   */
  var BigInteger;
  /**
   * This function creates a bigint value. It allows browsers
   * that doesn't support BigInt to run the rest of the library
   * by not directly accessing the BigInt constructor.
   */
  function createBigInt(num) {
      if (typeof BigInteger === 'undefined') {
          BigInteger = getBigIntConstructor();
      }
      if (BigInteger === null) {
          throw new Error('BigInt is not supported!');
      }
      return BigInteger(num);
  }
  function getEXP900() {
      // in Java - array with length = 16
      var EXP900 = [];
      EXP900[0] = createBigInt(1);
      var nineHundred = createBigInt(900);
      EXP900[1] = nineHundred;
      // in Java - array with length = 16
      for (var i /*int*/ = 2; i < 16; i++) {
          EXP900[i] = EXP900[i - 1] * nineHundred;
      }
      return EXP900;
  }
  /**
   * <p>This class contains the methods for decoding the PDF417 codewords.</p>
   *
   * @author SITA Lab (kevin.osullivan@sita.aero)
   * @author Guenther Grau
   */
  var DecodedBitStreamParser$2 = /** @class */ (function () {
      function DecodedBitStreamParser() {
      }
      //   private DecodedBitStreamParser() {
      // }
      /**
       *
       * @param codewords
       * @param ecLevel
       *
       * @throws FormatException
       */
      DecodedBitStreamParser.decode = function (codewords, ecLevel) {
          // pass encoding to result (will be used for decode symbols in byte mode)
          var result = new StringBuilder('');
          // let encoding: Charset = StandardCharsets.ISO_8859_1;
          var encoding = CharacterSetECI.ISO8859_1;
          /**
           * @note the next command is specific from this TypeScript library
           * because TS can't properly cast some values to char and
           * convert it to string later correctly due to encoding
           * differences from Java version. As reported here:
           * https://github.com/zxing-js/library/pull/264/files#r382831593
           */
          result.enableDecoding(encoding);
          // Get compaction mode
          var codeIndex = 1;
          var code = codewords[codeIndex++];
          var resultMetadata = new PDF417ResultMetadata();
          while (codeIndex < codewords[0]) {
              switch (code) {
                  case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                      codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);
                      break;
                  case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                      codeIndex = DecodedBitStreamParser.byteCompaction(code, codewords, encoding, codeIndex, result);
                      break;
                  case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                      result.append(/*(char)*/ codewords[codeIndex++]);
                      break;
                  case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                      codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex, result);
                      break;
                  case DecodedBitStreamParser.ECI_CHARSET:
                      var charsetECI = CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
                      // encoding = Charset.forName(charsetECI.getName());
                      break;
                  case DecodedBitStreamParser.ECI_GENERAL_PURPOSE:
                      // Can't do anything with generic ECI; skip its 2 characters
                      codeIndex += 2;
                      break;
                  case DecodedBitStreamParser.ECI_USER_DEFINED:
                      // Can't do anything with user ECI; skip its 1 character
                      codeIndex++;
                      break;
                  case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                      codeIndex = DecodedBitStreamParser.decodeMacroBlock(codewords, codeIndex, resultMetadata);
                      break;
                  case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                      // Should not see these outside a macro block
                      throw new FormatException();
                  default:
                      // Default to text compaction. During testing numerous barcodes
                      // appeared to be missing the starting mode. In these cases defaulting
                      // to text compaction seems to work.
                      codeIndex--;
                      codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);
                      break;
              }
              if (codeIndex < codewords.length) {
                  code = codewords[codeIndex++];
              }
              else {
                  throw FormatException.getFormatInstance();
              }
          }
          if (result.length() === 0) {
              throw FormatException.getFormatInstance();
          }
          var decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
          decoderResult.setOther(resultMetadata);
          return decoderResult;
      };
      /**
       *
       * @param int
       * @param param1
       * @param codewords
       * @param int
       * @param codeIndex
       * @param PDF417ResultMetadata
       * @param resultMetadata
       *
       * @throws FormatException
       */
      // @SuppressWarnings("deprecation")
      DecodedBitStreamParser.decodeMacroBlock = function (codewords, codeIndex, resultMetadata) {
          if (codeIndex + DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
              // we must have at least two bytes left for the segment index
              throw FormatException.getFormatInstance();
          }
          var segmentIndexArray = new Int32Array(DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS);
          for (var i /*int*/ = 0; i < DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
              segmentIndexArray[i] = codewords[codeIndex];
          }
          resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS)));
          var fileId = new StringBuilder();
          codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, fileId);
          resultMetadata.setFileId(fileId.toString());
          var optionalFieldsStart = -1;
          if (codewords[codeIndex] === DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
              optionalFieldsStart = codeIndex + 1;
          }
          while (codeIndex < codewords[0]) {
              switch (codewords[codeIndex]) {
                  case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                      codeIndex++;
                      switch (codewords[codeIndex]) {
                          case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                              var fileName = new StringBuilder();
                              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, fileName);
                              resultMetadata.setFileName(fileName.toString());
                              break;
                          case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                              var sender = new StringBuilder();
                              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, sender);
                              resultMetadata.setSender(sender.toString());
                              break;
                          case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                              var addressee = new StringBuilder();
                              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, addressee);
                              resultMetadata.setAddressee(addressee.toString());
                              break;
                          case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                              var segmentCount = new StringBuilder();
                              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, segmentCount);
                              resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                              break;
                          case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                              var timestamp = new StringBuilder();
                              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, timestamp);
                              resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                              break;
                          case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                              var checksum = new StringBuilder();
                              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, checksum);
                              resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                              break;
                          case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                              var fileSize = new StringBuilder();
                              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, fileSize);
                              resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                              break;
                          default:
                              throw FormatException.getFormatInstance();
                      }
                      break;
                  case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                      codeIndex++;
                      resultMetadata.setLastSegment(true);
                      break;
                  default:
                      throw FormatException.getFormatInstance();
              }
          }
          // copy optional fields to additional options
          if (optionalFieldsStart !== -1) {
              var optionalFieldsLength = codeIndex - optionalFieldsStart;
              if (resultMetadata.isLastSegment()) {
                  // do not include terminator
                  optionalFieldsLength--;
              }
              resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
          }
          return codeIndex;
      };
      /**
       * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be
       * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as
       * well as selected control characters.
       *
       * @param codewords The array of codewords (data + error)
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       */
      DecodedBitStreamParser.textCompaction = function (codewords, codeIndex, result) {
          // 2 character per codeword
          var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
          // Used to hold the byte compaction value if there is a mode shift
          var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
          var index = 0;
          var end = false;
          while ((codeIndex < codewords[0]) && !end) {
              var code = codewords[codeIndex++];
              if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                  textCompactionData[index] = code / 30;
                  textCompactionData[index + 1] = code % 30;
                  index += 2;
              }
              else {
                  switch (code) {
                      case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                          // reinitialize text compaction mode to alpha sub mode
                          textCompactionData[index++] = DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH;
                          break;
                      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                      case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                      case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                      case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                      case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                          codeIndex--;
                          end = true;
                          break;
                      case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                          // The Mode Shift codeword 913 shall cause a temporary
                          // switch from Text Compaction mode to Byte Compaction mode.
                          // This switch shall be in effect for only the next codeword,
                          // after which the mode shall revert to the prevailing sub-mode
                          // of the Text Compaction mode. Codeword 913 is only available
                          // in Text Compaction mode; its use is described in 5.4.2.4.
                          textCompactionData[index] = DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                          code = codewords[codeIndex++];
                          byteCompactionData[index] = code;
                          index++;
                          break;
                  }
              }
          }
          DecodedBitStreamParser.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
          return codeIndex;
      };
      /**
       * The Text Compaction mode includes all the printable ASCII characters
       * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab
       * (9: e), LF or line feed (10: e), and CR or carriage
       * return (13: e). The Text Compaction mode also includes various latch
       * and shift characters which are used exclusively within the mode. The Text
       * Compaction mode encodes up to 2 characters per codeword. The compaction rules
       * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode
       * switches are defined in 5.4.2.3.
       *
       * @param textCompactionData The text compaction data.
       * @param byteCompactionData The byte compaction data if there
       *                           was a mode shift.
       * @param length             The size of the text compaction and byte compaction data.
       * @param result             The decoded data is appended to the result.
       */
      DecodedBitStreamParser.decodeTextCompaction = function (textCompactionData, byteCompactionData, length, result) {
          // Beginning from an initial state of the Alpha sub-mode
          // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text
          // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text
          // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.
          var subMode = Mode$2.ALPHA;
          var priorToShiftMode = Mode$2.ALPHA;
          var i = 0;
          while (i < length) {
              var subModeCh = textCompactionData[i];
              var ch = /*char*/ '';
              switch (subMode) {
                  case Mode$2.ALPHA:
                      // Alpha (alphabetic: uppercase)
                      if (subModeCh < 26) {
                          // Upper case Alpha Character
                          // Note: 65 = 'A' ASCII -> there is byte code of symbol
                          ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);
                      }
                      else {
                          switch (subModeCh) {
                              case 26:
                                  ch = ' ';
                                  break;
                              case DecodedBitStreamParser.LL:
                                  subMode = Mode$2.LOWER;
                                  break;
                              case DecodedBitStreamParser.ML:
                                  subMode = Mode$2.MIXED;
                                  break;
                              case DecodedBitStreamParser.PS:
                                  // Shift to punctuation
                                  priorToShiftMode = subMode;
                                  subMode = Mode$2.PUNCT_SHIFT;
                                  break;
                              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                  result.append(/*(char)*/ byteCompactionData[i]);
                                  break;
                              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                  subMode = Mode$2.ALPHA;
                                  break;
                          }
                      }
                      break;
                  case Mode$2.LOWER:
                      // Lower (alphabetic: lowercase)
                      if (subModeCh < 26) {
                          ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);
                      }
                      else {
                          switch (subModeCh) {
                              case 26:
                                  ch = ' ';
                                  break;
                              case DecodedBitStreamParser.AS:
                                  // Shift to alpha
                                  priorToShiftMode = subMode;
                                  subMode = Mode$2.ALPHA_SHIFT;
                                  break;
                              case DecodedBitStreamParser.ML:
                                  subMode = Mode$2.MIXED;
                                  break;
                              case DecodedBitStreamParser.PS:
                                  // Shift to punctuation
                                  priorToShiftMode = subMode;
                                  subMode = Mode$2.PUNCT_SHIFT;
                                  break;
                              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                  // TODO Does this need to use the current character encoding? See other occurrences below
                                  result.append(/*(char)*/ byteCompactionData[i]);
                                  break;
                              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                  subMode = Mode$2.ALPHA;
                                  break;
                          }
                      }
                      break;
                  case Mode$2.MIXED:
                      // Mixed (punctuation: e)
                      if (subModeCh < DecodedBitStreamParser.PL) {
                          ch = DecodedBitStreamParser.MIXED_CHARS[subModeCh];
                      }
                      else {
                          switch (subModeCh) {
                              case DecodedBitStreamParser.PL:
                                  subMode = Mode$2.PUNCT;
                                  break;
                              case 26:
                                  ch = ' ';
                                  break;
                              case DecodedBitStreamParser.LL:
                                  subMode = Mode$2.LOWER;
                                  break;
                              case DecodedBitStreamParser.AL:
                                  subMode = Mode$2.ALPHA;
                                  break;
                              case DecodedBitStreamParser.PS:
                                  // Shift to punctuation
                                  priorToShiftMode = subMode;
                                  subMode = Mode$2.PUNCT_SHIFT;
                                  break;
                              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                  result.append(/*(char)*/ byteCompactionData[i]);
                                  break;
                              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                  subMode = Mode$2.ALPHA;
                                  break;
                          }
                      }
                      break;
                  case Mode$2.PUNCT:
                      // Punctuation
                      if (subModeCh < DecodedBitStreamParser.PAL) {
                          ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];
                      }
                      else {
                          switch (subModeCh) {
                              case DecodedBitStreamParser.PAL:
                                  subMode = Mode$2.ALPHA;
                                  break;
                              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                  result.append(/*(char)*/ byteCompactionData[i]);
                                  break;
                              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                  subMode = Mode$2.ALPHA;
                                  break;
                          }
                      }
                      break;
                  case Mode$2.ALPHA_SHIFT:
                      // Restore sub-mode
                      subMode = priorToShiftMode;
                      if (subModeCh < 26) {
                          ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);
                      }
                      else {
                          switch (subModeCh) {
                              case 26:
                                  ch = ' ';
                                  break;
                              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                  subMode = Mode$2.ALPHA;
                                  break;
                          }
                      }
                      break;
                  case Mode$2.PUNCT_SHIFT:
                      // Restore sub-mode
                      subMode = priorToShiftMode;
                      if (subModeCh < DecodedBitStreamParser.PAL) {
                          ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];
                      }
                      else {
                          switch (subModeCh) {
                              case DecodedBitStreamParser.PAL:
                                  subMode = Mode$2.ALPHA;
                                  break;
                              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                  // PS before Shift-to-Byte is used as a padding character,
                                  // see 5.4.2.4 of the specification
                                  result.append(/*(char)*/ byteCompactionData[i]);
                                  break;
                              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                  subMode = Mode$2.ALPHA;
                                  break;
                          }
                      }
                      break;
              }
              // if (ch !== 0) {
              if (ch !== '') {
                  // Append decoded character to result
                  result.append(ch);
              }
              i++;
          }
      };
      /**
       * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.
       * This includes all ASCII characters value 0 to 127 inclusive and provides for international
       * character set support.
       *
       * @param mode      The byte compaction mode i.e. 901 or 924
       * @param codewords The array of codewords (data + error)
       * @param encoding  Currently active character encoding
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       */
      DecodedBitStreamParser.byteCompaction = function (mode, codewords, encoding, codeIndex, result) {
          var decodedBytes = new ByteArrayOutputStream();
          var count = 0;
          var value = /*long*/ 0;
          var end = false;
          switch (mode) {
              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                  // Total number of Byte Compaction characters to be encoded
                  // is not a multiple of 6
                  var byteCompactedCodewords = new Int32Array(6);
                  var nextCode = codewords[codeIndex++];
                  while ((codeIndex < codewords[0]) && !end) {
                      byteCompactedCodewords[count++] = nextCode;
                      // Base 900
                      value = 900 * value + nextCode;
                      nextCode = codewords[codeIndex++];
                      // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH
                      switch (nextCode) {
                          case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                          case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                          case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                              codeIndex--;
                              end = true;
                              break;
                          default:
                              if ((count % 5 === 0) && (count > 0)) {
                                  // Decode every 5 codewords
                                  // Convert to Base 256
                                  for (var j /*int*/ = 0; j < 6; ++j) {
                                      /* @note
                                       * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.
                                       * So the next bitwise operation could not be done with simple numbers
                                       */
                                      decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                                  }
                                  value = 0;
                                  count = 0;
                              }
                              break;
                      }
                  }
                  // if the end of all codewords is reached the last codeword needs to be added
                  if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                      byteCompactedCodewords[count++] = nextCode;
                  }
                  // If Byte Compaction mode is invoked with codeword 901,
                  // the last group of codewords is interpreted directly
                  // as one byte per codeword, without compaction.
                  for (var i /*int*/ = 0; i < count; i++) {
                      decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);
                  }
                  break;
              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                  // Total number of Byte Compaction characters to be encoded
                  // is an integer multiple of 6
                  while (codeIndex < codewords[0] && !end) {
                      var code = codewords[codeIndex++];
                      if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                          count++;
                          // Base 900
                          value = 900 * value + code;
                      }
                      else {
                          switch (code) {
                              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                              case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                              case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                              case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                              case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                                  codeIndex--;
                                  end = true;
                                  break;
                          }
                      }
                      if ((count % 5 === 0) && (count > 0)) {
                          // Decode every 5 codewords
                          // Convert to Base 256
                          /* @note
                           * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.
                           * So the next bitwise operation could not be done with simple numbers
                          */
                          for (var j /*int*/ = 0; j < 6; ++j) {
                              decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                          }
                          value = 0;
                          count = 0;
                      }
                  }
                  break;
          }
          result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));
          return codeIndex;
      };
      /**
       * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.
       *
       * @param codewords The array of codewords (data + error)
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       *
       * @throws FormatException
       */
      DecodedBitStreamParser.numericCompaction = function (codewords, codeIndex /*int*/, result) {
          var count = 0;
          var end = false;
          var numericCodewords = new Int32Array(DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS);
          while (codeIndex < codewords[0] && !end) {
              var code = codewords[codeIndex++];
              if (codeIndex === codewords[0]) {
                  end = true;
              }
              if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                  numericCodewords[count] = code;
                  count++;
              }
              else {
                  switch (code) {
                      case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                      case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                      case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                      case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                          codeIndex--;
                          end = true;
                          break;
                  }
              }
              if ((count % DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
                  // Re-invoking Numeric Compaction mode (by using codeword 902
                  // while in Numeric Compaction mode) serves  to terminate the
                  // current Numeric Compaction mode grouping as described in 5.4.4.2,
                  // and then to start a new one grouping.
                  result.append(DecodedBitStreamParser.decodeBase900toBase10(numericCodewords, count));
                  count = 0;
              }
          }
          return codeIndex;
      };
      /**
       * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.
       *
       * @param codewords The array of codewords
       * @param count     The number of codewords
       * @return The decoded string representing the Numeric data.
       *
       * EXAMPLE
       * Encode the fifteen digit numeric string 000213298174000
       * Prefix the numeric string with a 1 and set the initial value of
       * t = 1 000 213 298 174 000
       * Calculate codeword 0
       * d0 = 1 000 213 298 174 000 mod 900 = 200
       *
       * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082
       * Calculate codeword 1
       * d1 = 1 111 348 109 082 mod 900 = 282
       *
       * t = 1 111 348 109 082 div 900 = 1 234 831 232
       * Calculate codeword 2
       * d2 = 1 234 831 232 mod 900 = 632
       *
       * t = 1 234 831 232 div 900 = 1 372 034
       * Calculate codeword 3
       * d3 = 1 372 034 mod 900 = 434
       *
       * t = 1 372 034 div 900 = 1 524
       * Calculate codeword 4
       * d4 = 1 524 mod 900 = 624
       *
       * t = 1 524 div 900 = 1
       * Calculate codeword 5
       * d5 = 1 mod 900 = 1
       * t = 1 div 900 = 0
       * Codeword sequence is: 1, 624, 434, 632, 282, 200
       *
       * Decode the above codewords involves
       *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +
       * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000
       *
       * Remove leading 1 =>  Result is 000213298174000
       *
       * @throws FormatException
       */
      DecodedBitStreamParser.decodeBase900toBase10 = function (codewords, count) {
          var result = createBigInt(0);
          for (var i /*int*/ = 0; i < count; i++) {
              result += DecodedBitStreamParser.EXP900[count - i - 1] * createBigInt(codewords[i]);
          }
          var resultString = result.toString();
          if (resultString.charAt(0) !== '1') {
              throw new FormatException();
          }
          return resultString.substring(1);
      };
      DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH = 900;
      DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH = 901;
      DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH = 902;
      DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6 = 924;
      DecodedBitStreamParser.ECI_USER_DEFINED = 925;
      DecodedBitStreamParser.ECI_GENERAL_PURPOSE = 926;
      DecodedBitStreamParser.ECI_CHARSET = 927;
      DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
      DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
      DecodedBitStreamParser.MACRO_PDF417_TERMINATOR = 922;
      DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
      DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS = 15;
      DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
      DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
      DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
      DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
      DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
      DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
      DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
      DecodedBitStreamParser.PL = 25;
      DecodedBitStreamParser.LL = 27;
      DecodedBitStreamParser.AS = 27;
      DecodedBitStreamParser.ML = 28;
      DecodedBitStreamParser.AL = 28;
      DecodedBitStreamParser.PS = 29;
      DecodedBitStreamParser.PAL = 29;
      DecodedBitStreamParser.PUNCT_CHARS = ';<>@[\\]_`~!\r\t,:\n-.$/"|*()?{}\'';
      DecodedBitStreamParser.MIXED_CHARS = '0123456789&\r\t,:#-.$/+%*=^';
      /**
       * Table containing values for the exponent of 900.
       * This is used in the numeric compaction decode algorithm.
       */
      DecodedBitStreamParser.EXP900 = getBigIntConstructor() ? getEXP900() : [];
      DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
      return DecodedBitStreamParser;
  }());

  /*
  * Copyright 2013 ZXing authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var __values$y = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  // import java.util.ArrayList;
  // import java.util.Collection;
  // import java.util.Formatter;
  // import java.util.List;
  /**
   * @author Guenther Grau
   */
  var PDF417ScanningDecoder = /** @class */ (function () {
      function PDF417ScanningDecoder() {
      }
      /**
       * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern
       *
       * columns. That way width can be deducted from the pattern column.
       * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider
       * than it should be. This can happen if the scanner used a bad blackpoint.
       *
       * @param BitMatrix
       * @param image
       * @param ResultPoint
       * @param imageTopLeft
       * @param ResultPoint
       * @param imageBottomLeft
       * @param ResultPoint
       * @param imageTopRight
       * @param ResultPoint
       * @param imageBottomRight
       * @param int
       * @param minCodewordWidth
       * @param int
       * @param maxCodewordWidth
       *
       * @throws NotFoundException
       * @throws FormatException
       * @throws ChecksumException
       */
      PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
          var boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
          var leftRowIndicatorColumn = null;
          var rightRowIndicatorColumn = null;
          var detectionResult;
          for (var firstPass /*boolean*/ = true;; firstPass = false) {
              if (imageTopLeft != null) {
                  leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
              }
              if (imageTopRight != null) {
                  rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
              }
              detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
              if (detectionResult == null) {
                  throw NotFoundException.getNotFoundInstance();
              }
              var resultBox = detectionResult.getBoundingBox();
              if (firstPass && resultBox != null &&
                  (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
                  boundingBox = resultBox;
              }
              else {
                  break;
              }
          }
          detectionResult.setBoundingBox(boundingBox);
          var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
          detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
          detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
          var leftToRight = leftRowIndicatorColumn != null;
          for (var barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
              var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
              if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {
                  // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.
                  continue;
              }
              var detectionResultColumn = void 0;
              if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
                  detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);
              }
              else {
                  detectionResultColumn = new DetectionResultColumn(boundingBox);
              }
              detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
              var startColumn = -1;
              var previousStartColumn = startColumn;
              // TODO start at a row for which we know the start position, then detect upwards and downwards from there.
              for (var imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
                  startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
                  if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
                      if (previousStartColumn === -1) {
                          continue;
                      }
                      startColumn = previousStartColumn;
                  }
                  var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                  if (codeword != null) {
                      detectionResultColumn.setCodeword(imageRow, codeword);
                      previousStartColumn = startColumn;
                      minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
                      maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
                  }
              }
          }
          return PDF417ScanningDecoder.createDecoderResult(detectionResult);
      };
      /**
       *
       * @param leftRowIndicatorColumn
       * @param rightRowIndicatorColumn
       *
       * @throws NotFoundException
       */
      PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {
          if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
              return null;
          }
          var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
          if (barcodeMetadata == null) {
              return null;
          }
          var boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
          return new DetectionResult(barcodeMetadata, boundingBox);
      };
      /**
       *
       * @param rowIndicatorColumn
       *
       * @throws NotFoundException
       */
      PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {
          var e_1, _a;
          if (rowIndicatorColumn == null) {
              return null;
          }
          var rowHeights = rowIndicatorColumn.getRowHeights();
          if (rowHeights == null) {
              return null;
          }
          var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
          var missingStartRows = 0;
          try {
              for (var rowHeights_1 = __values$y(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {
                  var rowHeight = rowHeights_1_1.value /*int*/;
                  missingStartRows += maxRowHeight - rowHeight;
                  if (rowHeight > 0) {
                      break;
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          var codewords = rowIndicatorColumn.getCodewords();
          for (var row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {
              missingStartRows--;
          }
          var missingEndRows = 0;
          for (var row /*int*/ = rowHeights.length - 1; row >= 0; row--) {
              missingEndRows += maxRowHeight - rowHeights[row];
              if (rowHeights[row] > 0) {
                  break;
              }
          }
          for (var row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
              missingEndRows--;
          }
          return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
      };
      PDF417ScanningDecoder.getMax = function (values) {
          var e_2, _a;
          var maxValue = -1;
          try {
              for (var values_1 = __values$y(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                  var value = values_1_1.value /*int*/;
                  maxValue = Math.max(maxValue, value);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
              }
              finally { if (e_2) throw e_2.error; }
          }
          return maxValue;
      };
      PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {
          var leftBarcodeMetadata;
          if (leftRowIndicatorColumn == null ||
              (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
              return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
          }
          var rightBarcodeMetadata;
          if (rightRowIndicatorColumn == null ||
              (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
              return leftBarcodeMetadata;
          }
          if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&
              leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&
              leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
              return null;
          }
          return leftBarcodeMetadata;
      };
      PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
          var rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);
          for (var i /*int*/ = 0; i < 2; i++) {
              var increment = i === 0 ? 1 : -1;
              var startColumn = Math.trunc(Math.trunc(startPoint.getX()));
              for (var imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&
                  imageRow >= boundingBox.getMinY(); imageRow += increment) {
                  var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                  if (codeword != null) {
                      rowIndicatorColumn.setCodeword(imageRow, codeword);
                      if (leftToRight) {
                          startColumn = codeword.getStartX();
                      }
                      else {
                          startColumn = codeword.getEndX();
                      }
                  }
              }
          }
          return rowIndicatorColumn;
      };
      /**
       *
       * @param detectionResult
       * @param BarcodeValue
       * @param param2
       * @param param3
       * @param barcodeMatrix
       *
       * @throws NotFoundException
       */
      PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {
          var barcodeMatrix01 = barcodeMatrix[0][1];
          var numberOfCodewords = barcodeMatrix01.getValue();
          var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *
              detectionResult.getBarcodeRowCount() -
              PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
          if (numberOfCodewords.length === 0) {
              if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {
                  throw NotFoundException.getNotFoundInstance();
              }
              barcodeMatrix01.setValue(calculatedNumberOfCodewords);
          }
          else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
              // The calculated one is more reliable as it is derived from the row indicator columns
              barcodeMatrix01.setValue(calculatedNumberOfCodewords);
          }
      };
      /**
       *
       * @param detectionResult
       *
       * @throws FormatException
       * @throws ChecksumException
       * @throws NotFoundException
       */
      PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {
          var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
          PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
          var erasures /*Collection<Integer>*/ = new Array();
          var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
          var ambiguousIndexValuesList = /*List<int[]>*/ [];
          var ambiguousIndexesList = /*Collection<Integer>*/ new Array();
          for (var row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {
              for (var column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
                  var values = barcodeMatrix[row][column + 1].getValue();
                  var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
                  if (values.length === 0) {
                      erasures.push(codewordIndex);
                  }
                  else if (values.length === 1) {
                      codewords[codewordIndex] = values[0];
                  }
                  else {
                      ambiguousIndexesList.push(codewordIndex);
                      ambiguousIndexValuesList.push(values);
                  }
              }
          }
          var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
          for (var i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {
              ambiguousIndexValues[i] = ambiguousIndexValuesList[i];
          }
          return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
      };
      /**
       * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The
       * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value
       * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of
       * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the
       * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,
       * so decoding the normal barcodes is not affected by this.
       *
       * @param erasureArray contains the indexes of erasures
       * @param ambiguousIndexes array with the indexes that have more than one most likely value
       * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must
       * be the same length as the ambiguousIndexes array
       *
       * @throws FormatException
       * @throws ChecksumException
       */
      PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
          var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
          var tries = 100;
          while (tries-- > 0) {
              for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {
                  codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];
              }
              try {
                  return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
              }
              catch (err) {
                  var ignored = err instanceof ChecksumException;
                  if (!ignored) {
                      throw err;
                  }
              }
              if (ambiguousIndexCount.length === 0) {
                  throw ChecksumException.getChecksumInstance();
              }
              for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {
                  if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {
                      ambiguousIndexCount[i]++;
                      break;
                  }
                  else {
                      ambiguousIndexCount[i] = 0;
                      if (i === ambiguousIndexCount.length - 1) {
                          throw ChecksumException.getChecksumInstance();
                      }
                  }
              }
          }
          throw ChecksumException.getChecksumInstance();
      };
      PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {
          var e_3, _a, e_4, _b;
          // let barcodeMatrix: BarcodeValue[][] =
          // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];
          var barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, function () { return new Array(detectionResult.getBarcodeColumnCount() + 2); });
          for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {
              for (var column_1 /*int*/ = 0; column_1 < barcodeMatrix[row].length; column_1++) {
                  barcodeMatrix[row][column_1] = new BarcodeValue();
              }
          }
          var column = 0;
          try {
              for (var _c = __values$y(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var detectionResultColumn = _d.value /*DetectionResultColumn*/;
                  if (detectionResultColumn != null) {
                      try {
                          for (var _e = (e_4 = void 0, __values$y(detectionResultColumn.getCodewords())), _f = _e.next(); !_f.done; _f = _e.next()) {
                              var codeword = _f.value /*Codeword*/;
                              if (codeword != null) {
                                  var rowNumber = codeword.getRowNumber();
                                  if (rowNumber >= 0) {
                                      if (rowNumber >= barcodeMatrix.length) {
                                          // We have more rows than the barcode metadata allows for, ignore them.
                                          continue;
                                      }
                                      barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                                  }
                              }
                          }
                      }
                      catch (e_4_1) { e_4 = { error: e_4_1 }; }
                      finally {
                          try {
                              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                          }
                          finally { if (e_4) throw e_4.error; }
                      }
                  }
                  column++;
              }
          }
          catch (e_3_1) { e_3 = { error: e_3_1 }; }
          finally {
              try {
                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              }
              finally { if (e_3) throw e_3.error; }
          }
          return barcodeMatrix;
      };
      PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {
          return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
      };
      PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {
          var e_5, _a;
          var offset = leftToRight ? 1 : -1;
          var codeword = null;
          if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
              codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
          }
          if (codeword != null) {
              return leftToRight ? codeword.getEndX() : codeword.getStartX();
          }
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
          if (codeword != null) {
              return leftToRight ? codeword.getStartX() : codeword.getEndX();
          }
          if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
              codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
          }
          if (codeword != null) {
              return leftToRight ? codeword.getEndX() : codeword.getStartX();
          }
          var skippedColumns = 0;
          while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
              barcodeColumn -= offset;
              try {
                  for (var _b = (e_5 = void 0, __values$y(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords())), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var previousRowCodeword = _c.value /*Codeword*/;
                      if (previousRowCodeword != null) {
                          return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +
                              offset *
                                  skippedColumns *
                                  (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
                      }
                  }
              }
              catch (e_5_1) { e_5 = { error: e_5_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_5) throw e_5.error; }
              }
              skippedColumns++;
          }
          return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
      };
      PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
          startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
          // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length
          // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.
          // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate
          // for the current position
          var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
          if (moduleBitCount == null) {
              return null;
          }
          var endColumn;
          var codewordBitCount = MathUtils.sum(moduleBitCount);
          if (leftToRight) {
              endColumn = startColumn + codewordBitCount;
          }
          else {
              for (var i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {
                  var tmpCount = moduleBitCount[i];
                  moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];
                  moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;
              }
              endColumn = startColumn;
              startColumn = endColumn - codewordBitCount;
          }
          // TODO implement check for width and correction of black and white bars
          // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.
          // should probably done only for codewords with a lot more than 17 bits.
          // The following fixes 10-1.png, which has wide black bars and small white bars
          //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {
          //      if (i % 2 === 0) {
          //        moduleBitCount[i]--;
          //      } else {
          //        moduleBitCount[i]++;
          //      }
          //    }
          // We could also use the width of surrounding codewords for more accurate results, but this seems
          // sufficient for now
          if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
              // We could try to use the startX and endX position of the codeword in the same column in the previous row,
              // create the bit count from it and normalize it to 8. This would help with single pixel errors.
              return null;
          }
          var decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
          var codeword = PDF417Common.getCodeword(decodedValue);
          if (codeword === -1) {
              return null;
          }
          return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
      };
      PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
          var imageColumn = startColumn;
          var moduleBitCount = new Int32Array(8);
          var moduleNumber = 0;
          var increment = leftToRight ? 1 : -1;
          var previousPixelValue = leftToRight;
          while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&
              moduleNumber < moduleBitCount.length) {
              if (image.get(imageColumn, imageRow) === previousPixelValue) {
                  moduleBitCount[moduleNumber]++;
                  imageColumn += increment;
              }
              else {
                  moduleNumber++;
                  previousPixelValue = !previousPixelValue;
              }
          }
          if (moduleNumber === moduleBitCount.length ||
              ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&
                  moduleNumber === moduleBitCount.length - 1)) {
              return moduleBitCount;
          }
          return null;
      };
      PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {
          return 2 << barcodeECLevel;
      };
      PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
          var correctedStartColumn = codewordStartColumn;
          var increment = leftToRight ? -1 : 1;
          // there should be no black pixels before the start column. If there are, then we need to start earlier.
          for (var i /*int*/ = 0; i < 2; i++) {
              while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&
                  leftToRight === image.get(correctedStartColumn, imageRow)) {
                  if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
                      return codewordStartColumn;
                  }
                  correctedStartColumn += increment;
              }
              increment = -increment;
              leftToRight = !leftToRight;
          }
          return correctedStartColumn;
      };
      PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {
          return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&
              codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
      };
      /**
       * @throws FormatException,
       * @throws ChecksumException
       */
      PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {
          if (codewords.length === 0) {
              throw FormatException.getFormatInstance();
          }
          var numECCodewords = 1 << (ecLevel + 1);
          var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
          PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
          // Decode the codewords
          var decoderResult = DecodedBitStreamParser$2.decode(codewords, '' + ecLevel);
          decoderResult.setErrorsCorrected(correctedErrorsCount);
          decoderResult.setErasures(erasures.length);
          return decoderResult;
      };
      /**
       * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
       * correct the errors in-place.</p>
       *
       * @param codewords   data and error correction codewords
       * @param erasures positions of any known erasures
       * @param numECCodewords number of error correction codewords that are available in codewords
       * @throws ChecksumException if error correction fails
       */
      PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {
          if (erasures != null &&
              erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||
              numECCodewords < 0 ||
              numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
              // Too many errors or EC Codewords is corrupted
              throw ChecksumException.getChecksumInstance();
          }
          return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
      };
      /**
       * Verify that all is OK with the codeword array.
       * @throws FormatException
       */
      PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {
          if (codewords.length < 4) {
              // Codeword array size should be at least 4 allowing for
              // Count CW, At least one Data CW, Error Correction CW, Error Correction CW
              throw FormatException.getFormatInstance();
          }
          // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data
          // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad
          // codewords, but excluding the number of error correction codewords.
          var numberOfCodewords = codewords[0];
          if (numberOfCodewords > codewords.length) {
              throw FormatException.getFormatInstance();
          }
          if (numberOfCodewords === 0) {
              // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)
              if (numECCodewords < codewords.length) {
                  codewords[0] = codewords.length - numECCodewords;
              }
              else {
                  throw FormatException.getFormatInstance();
              }
          }
      };
      PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {
          var result = new Int32Array(8);
          var previousValue = 0;
          var i = result.length - 1;
          while (true) {
              if ((codeword & 0x1) !== previousValue) {
                  previousValue = codeword & 0x1;
                  i--;
                  if (i < 0) {
                      break;
                  }
              }
              result[i]++;
              codeword >>= 1;
          }
          return result;
      };
      PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {
          if (codeword instanceof Int32Array) {
              return this.getCodewordBucketNumber_Int32Array(codeword);
          }
          return this.getCodewordBucketNumber_number(codeword);
      };
      PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {
          return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
      };
      PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {
          return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
      };
      PDF417ScanningDecoder.toString = function (barcodeMatrix) {
          var formatter = new Formatter();
          // try (let formatter = new Formatter()) {
          for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {
              formatter.format('Row %2d: ', row);
              for (var column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {
                  var barcodeValue = barcodeMatrix[row][column];
                  if (barcodeValue.getValue().length === 0) {
                      formatter.format('        ', null);
                  }
                  else {
                      formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
                  }
              }
              formatter.format('%n');
          }
          return formatter.toString();
          // }
      };
      /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
      /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;
      /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
      /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();
      return PDF417ScanningDecoder;
  }());

  /*
   * Copyright 2009 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __values$z = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  // import java.util.ArrayList;
  // import java.util.List;
  // import java.util.Map;
  /**
   * This implementation can detect and decode PDF417 codes in an image.
   *
   * @author Guenther Grau
   */
  var PDF417Reader = /** @class */ (function () {
      function PDF417Reader() {
      }
      // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);
      /**
       * Locates and decodes a PDF417 code in an image.
       *
       * @return a String representing the content encoded by the PDF417 code
       * @throws NotFoundException if a PDF417 code cannot be found,
       * @throws FormatException if a PDF417 cannot be decoded
       * @throws ChecksumException
       */
      // @Override
      PDF417Reader.prototype.decode = function (image, hints) {
          if (hints === void 0) { hints = null; }
          var result = PDF417Reader.decode(image, hints, false);
          if (result == null || result.length === 0 || result[0] == null) {
              throw NotFoundException.getNotFoundInstance();
          }
          return result[0];
      };
      /**
       *
       * @param BinaryBitmap
       * @param image
       * @throws NotFoundException
       */
      //   @Override
      PDF417Reader.prototype.decodeMultiple = function (image, hints) {
          if (hints === void 0) { hints = null; }
          try {
              return PDF417Reader.decode(image, hints, true);
          }
          catch (ignored) {
              if (ignored instanceof FormatException || ignored instanceof ChecksumException) {
                  throw NotFoundException.getNotFoundInstance();
              }
              throw ignored;
          }
      };
      /**
       *
       * @param image
       * @param hints
       * @param multiple
       *
       * @throws NotFoundException
       * @throws FormatExceptionß
       * @throws ChecksumException
       */
      PDF417Reader.decode = function (image, hints, multiple) {
          var e_1, _a;
          var results = new Array();
          var detectorResult = Detector$3.detectMultiple(image, hints, multiple);
          try {
              for (var _b = __values$z(detectorResult.getPoints()), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var points = _c.value;
                  var decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
                  var result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.PDF_417);
                  result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
                  var pdf417ResultMetadata = decoderResult.getOther();
                  if (pdf417ResultMetadata != null) {
                      result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
                  }
                  results.push(result);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return results.map(function (x) { return x; });
      };
      PDF417Reader.getMaxWidth = function (p1, p2) {
          if (p1 == null || p2 == null) {
              return 0;
          }
          return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      };
      PDF417Reader.getMinWidth = function (p1, p2) {
          if (p1 == null || p2 == null) {
              return Integer.MAX_VALUE;
          }
          return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      };
      PDF417Reader.getMaxCodewordWidth = function (p) {
          return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /
              PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /
              PDF417Common.MODULES_IN_STOP_PATTERN)));
      };
      PDF417Reader.getMinCodewordWidth = function (p) {
          return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /
              PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /
              PDF417Common.MODULES_IN_STOP_PATTERN)));
      };
      // @Override
      PDF417Reader.prototype.reset = function () {
          // nothing needs to be reset
      };
      return PDF417Reader;
  }());

  var __extends$W = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Custom Error class of type Exception.
   */
  var ReaderException = /** @class */ (function (_super) {
      __extends$W(ReaderException, _super);
      function ReaderException() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ReaderException.kind = 'ReaderException';
      return ReaderException;
  }(Exception));

  /*
   * Copyright 2009 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __values$A = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  /*namespace com.google.zxing {*/
  /**
   * MultiFormatReader is a convenience class and the main entry point into the library for most uses.
   * By default it attempts to decode all barcode formats that the library supports. Optionally, you
   * can provide a hints object to request different behavior, for example only decoding QR codes.
   *
   * @author Sean Owen
   * @author dswitkin@google.com (Daniel Switkin)
   */
  var MultiFormatReader = /** @class */ (function () {
      function MultiFormatReader() {
      }
      /**
       * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it
       * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.
       * Use setHints() followed by decodeWithState() for continuous scan applications.
       *
       * @param image The pixel data to decode
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      /*@Override*/
      // public decode(image: BinaryBitmap): Result {
      //   setHints(null)
      //   return decodeInternal(image)
      // }
      /**
       * Decode an image using the hints provided. Does not honor existing state.
       *
       * @param image The pixel data to decode
       * @param hints The hints to use, clearing the previous state.
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      /*@Override*/
      MultiFormatReader.prototype.decode = function (image, hints) {
          this.setHints(hints);
          return this.decodeInternal(image);
      };
      /**
       * Decode an image using the state set up by calling setHints() previously. Continuous scan
       * clients will get a <b>large</b> speed increase by using this instead of decode().
       *
       * @param image The pixel data to decode
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      MultiFormatReader.prototype.decodeWithState = function (image) {
          // Make sure to set up the default state so we don't crash
          if (this.readers === null || this.readers === undefined) {
              this.setHints(null);
          }
          return this.decodeInternal(image);
      };
      /**
       * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls
       * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This
       * is important for performance in continuous scan clients.
       *
       * @param hints The set of hints to use for subsequent calls to decode(image)
       */
      MultiFormatReader.prototype.setHints = function (hints) {
          this.hints = hints;
          var tryHarder = hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.TRY_HARDER);
          /*@SuppressWarnings("unchecked")*/
          var formats = hints === null || hints === undefined ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
          var readers = new Array();
          if (formats !== null && formats !== undefined) {
              var addOneDReader = formats.some(function (f) {
                  return f === BarcodeFormat$1.UPC_A ||
                      f === BarcodeFormat$1.UPC_E ||
                      f === BarcodeFormat$1.EAN_13 ||
                      f === BarcodeFormat$1.EAN_8 ||
                      f === BarcodeFormat$1.CODABAR ||
                      f === BarcodeFormat$1.CODE_39 ||
                      f === BarcodeFormat$1.CODE_93 ||
                      f === BarcodeFormat$1.CODE_128 ||
                      f === BarcodeFormat$1.ITF ||
                      f === BarcodeFormat$1.RSS_14 ||
                      f === BarcodeFormat$1.RSS_EXPANDED;
              });
              // Put 1D readers upfront in "normal" mode
              // TYPESCRIPTPORT: TODO: uncomment below as they are ported
              if (addOneDReader && !tryHarder) {
                  readers.push(new MultiFormatOneDReader(hints));
              }
              if (formats.includes(BarcodeFormat$1.QR_CODE)) {
                  readers.push(new QRCodeReader());
              }
              if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {
                  readers.push(new DataMatrixReader());
              }
              if (formats.includes(BarcodeFormat$1.AZTEC)) {
                  readers.push(new AztecReader());
              }
              if (formats.includes(BarcodeFormat$1.PDF_417)) {
                  readers.push(new PDF417Reader());
              }
              // if (formats.includes(BarcodeFormat.MAXICODE)) {
              //    readers.push(new MaxiCodeReader())
              // }
              // At end in "try harder" mode
              if (addOneDReader && tryHarder) {
                  readers.push(new MultiFormatOneDReader(hints));
              }
          }
          if (readers.length === 0) {
              if (!tryHarder) {
                  readers.push(new MultiFormatOneDReader(hints));
              }
              readers.push(new QRCodeReader());
              readers.push(new DataMatrixReader());
              readers.push(new AztecReader());
              readers.push(new PDF417Reader());
              // readers.push(new MaxiCodeReader())
              if (tryHarder) {
                  readers.push(new MultiFormatOneDReader(hints));
              }
          }
          this.readers = readers; // .toArray(new Reader[readers.size()])
      };
      /*@Override*/
      MultiFormatReader.prototype.reset = function () {
          var e_1, _a;
          if (this.readers !== null) {
              try {
                  for (var _b = __values$A(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var reader = _c.value;
                      reader.reset();
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
      };
      /**
       * @throws NotFoundException
       */
      MultiFormatReader.prototype.decodeInternal = function (image) {
          var e_2, _a;
          if (this.readers === null) {
              throw new ReaderException('No readers where selected, nothing can be read.');
          }
          try {
              for (var _b = __values$A(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var reader = _c.value;
                  // Trying to decode with ${reader} reader.
                  try {
                      return reader.decode(image, this.hints);
                  }
                  catch (ex) {
                      if (ex instanceof ReaderException) {
                          continue;
                      }
                      // Bad Exception.
                  }
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          throw new NotFoundException('No MultiFormat Readers were able to detect the code.');
      };
      return MultiFormatReader;
  }());

  var __extends$X = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var BrowserMultiFormatReader = /** @class */ (function (_super) {
      __extends$X(BrowserMultiFormatReader, _super);
      function BrowserMultiFormatReader(hints, timeBetweenScansMillis) {
          if (hints === void 0) { hints = null; }
          if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
          var _this = this;
          var reader = new MultiFormatReader();
          reader.setHints(hints);
          _this = _super.call(this, reader, timeBetweenScansMillis) || this;
          return _this;
      }
      /**
       * Overwrite decodeBitmap to call decodeWithState, which will pay
       * attention to the hints set in the constructor function
       */
      BrowserMultiFormatReader.prototype.decodeBitmap = function (binaryBitmap) {
          return this.reader.decodeWithState(binaryBitmap);
      };
      return BrowserMultiFormatReader;
  }(BrowserCodeReader));

  var __extends$Y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @deprecated Moving to @zxing/browser
   *
   * QR Code reader to use from browser.
   */
  var BrowserPDF417Reader = /** @class */ (function (_super) {
      __extends$Y(BrowserPDF417Reader, _super);
      /**
       * Creates an instance of BrowserPDF417Reader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      function BrowserPDF417Reader(timeBetweenScansMillis) {
          if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
          return _super.call(this, new PDF417Reader(), timeBetweenScansMillis) || this;
      }
      return BrowserPDF417Reader;
  }(BrowserCodeReader));

  var __extends$Z = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @deprecated Moving to @zxing/browser
   *
   * QR Code reader to use from browser.
   */
  var BrowserQRCodeReader = /** @class */ (function (_super) {
      __extends$Z(BrowserQRCodeReader, _super);
      /**
       * Creates an instance of BrowserQRCodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      function BrowserQRCodeReader(timeBetweenScansMillis) {
          if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
          return _super.call(this, new QRCodeReader(), timeBetweenScansMillis) || this;
      }
      return BrowserQRCodeReader;
  }(BrowserCodeReader));

  /*
   * Copyright 2009 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /*namespace com.google.zxing {*/
  /**
   * These are a set of hints that you may pass to Writers to specify their behavior.
   *
   * @author dswitkin@google.com (Daniel Switkin)
   */
  var EncodeHintType;
  (function (EncodeHintType) {
      /**
       * Specifies what degree of error correction to use, for example in QR Codes.
       * Type depends on the encoder. For example for QR codes it's type
       * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.
       * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.
       * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.
       * In all cases, it can also be a {@link String} representation of the desired value as well.
       * Note: an Aztec symbol should have a minimum of 25% EC words.
       */
      EncodeHintType[EncodeHintType["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
      /**
       * Specifies what character encoding to use where applicable (type {@link String})
       */
      EncodeHintType[EncodeHintType["CHARACTER_SET"] = 1] = "CHARACTER_SET";
      /**
       * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})
       */
      EncodeHintType[EncodeHintType["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
      /**
       * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.
       *
       * @deprecated use width/height params in
       * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}
       */
      /*@Deprecated*/
      EncodeHintType[EncodeHintType["MIN_SIZE"] = 3] = "MIN_SIZE";
      /**
       * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.
       *
       * @deprecated without replacement
       */
      /*@Deprecated*/
      EncodeHintType[EncodeHintType["MAX_SIZE"] = 4] = "MAX_SIZE";
      /**
       * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary
       * by format; for example it controls margin before and after the barcode horizontally for
       * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).
       */
      EncodeHintType[EncodeHintType["MARGIN"] = 5] = "MARGIN";
      /**
       * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or "true" or "false"
       * {@link String} value).
       */
      EncodeHintType[EncodeHintType["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
      /**
       * Specifies what compaction mode to use for PDF417 (type
       * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its
       * enum values).
       */
      EncodeHintType[EncodeHintType["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
      /**
       * Specifies the minimum and maximum number of rows and columns for PDF417 (type
       * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).
       */
      EncodeHintType[EncodeHintType["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
      /**
       * Specifies the required number of layers for an Aztec code.
       * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.
       * 0 indicates to use the minimum number of layers (the default).
       * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.
       * (Type {@link Integer}, or {@link String} representation of the integer value).
       */
      EncodeHintType[EncodeHintType["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
      /**
       * Specifies the exact version of QR code to be encoded.
       * (Type {@link Integer}, or {@link String} representation of the integer value).
       */
      EncodeHintType[EncodeHintType["QR_VERSION"] = 10] = "QR_VERSION";
  })(EncodeHintType || (EncodeHintType = {}));
  var EncodeHintType$1 = EncodeHintType;

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * <p>Implements Reed-Solomon encoding, as the name implies.</p>
   *
   * @author Sean Owen
   * @author William Rucklidge
   */
  var ReedSolomonEncoder = /** @class */ (function () {
      /**
       * A reed solomon error-correcting encoding constructor is created by
       * passing as Galois Field with of size equal to the number of code
       * words (symbols) in the alphabet (the number of values in each
       * element of arrays that are encoded/decoded).
       * @param field A galois field with a number of elements equal to the size
       * of the alphabet of symbols to encode.
       */
      function ReedSolomonEncoder(field) {
          this.field = field;
          this.cachedGenerators = [];
          this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));
      }
      ReedSolomonEncoder.prototype.buildGenerator = function (degree /*int*/) {
          var cachedGenerators = this.cachedGenerators;
          if (degree >= cachedGenerators.length) {
              var lastGenerator = cachedGenerators[cachedGenerators.length - 1];
              var field = this.field;
              for (var d = cachedGenerators.length; d <= degree; d++) {
                  var nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));
                  cachedGenerators.push(nextGenerator);
                  lastGenerator = nextGenerator;
              }
          }
          return cachedGenerators[degree];
      };
      /**
       * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders
       * to detect and correct errors that may have been introduced when the resulting
       * data is stored or transmitted.</p>
       *
       * @param toEncode array used for both and output. Caller initializes the array with
       * the code words (symbols) to be encoded followed by empty elements allocated to make
       * space for error-correction code words in the encoded output. The array contains
       * the encdoded output when encode returns. Code words are encoded as numbers from
       * 0 to n-1, where n is the number of possible code words (symbols), as determined
       * by the size of the Galois Field passed in the constructor of this object.
       * @param ecBytes the number of elements reserved in the array (first parameter)
       * to store error-correction code words. Thus, the number of code words (symbols)
       * to encode in the first parameter is thus toEncode.length - ecBytes.
       * Note, the use of "bytes" in the name of this parameter is misleading, as there may
       * be more or fewer than 256 symbols being encoded, as determined by the number of
       * elements in the Galois Field passed as a constructor to this object.
       * @throws IllegalArgumentException thrown in response to validation errros.
       */
      ReedSolomonEncoder.prototype.encode = function (toEncode, ecBytes /*int*/) {
          if (ecBytes === 0) {
              throw new IllegalArgumentException('No error correction bytes');
          }
          var dataBytes = toEncode.length - ecBytes;
          if (dataBytes <= 0) {
              throw new IllegalArgumentException('No data bytes provided');
          }
          var generator = this.buildGenerator(ecBytes);
          var infoCoefficients = new Int32Array(dataBytes);
          System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
          var info = new GenericGFPoly(this.field, infoCoefficients);
          info = info.multiplyByMonomial(ecBytes, 1);
          var remainder = info.divide(generator)[1];
          var coefficients = remainder.getCoefficients();
          var numZeroCoefficients = ecBytes - coefficients.length;
          for (var i = 0; i < numZeroCoefficients; i++) {
              toEncode[dataBytes + i] = 0;
          }
          System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
      };
      return ReedSolomonEncoder;
  }());

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @author Satoru Takabayashi
   * @author Daniel Switkin
   * @author Sean Owen
   */
  var MaskUtil = /** @class */ (function () {
      function MaskUtil() {
          // do nothing
      }
      /**
       * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
       * give penalty to them. Example: 00000 or 11111.
       */
      MaskUtil.applyMaskPenaltyRule1 = function (matrix) {
          return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
      };
      /**
       * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
       * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
       * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
       */
      MaskUtil.applyMaskPenaltyRule2 = function (matrix) {
          var penalty = 0;
          var array = matrix.getArray();
          var width = matrix.getWidth();
          var height = matrix.getHeight();
          for (var y = 0; y < height - 1; y++) {
              var arrayY = array[y];
              for (var x = 0; x < width - 1; x++) {
                  var value = arrayY[x];
                  if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {
                      penalty++;
                  }
              }
          }
          return MaskUtil.N2 * penalty;
      };
      /**
       * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4
       * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we
       * find patterns like 000010111010000, we give penalty once.
       */
      MaskUtil.applyMaskPenaltyRule3 = function (matrix) {
          var numPenalties = 0;
          var array = matrix.getArray();
          var width = matrix.getWidth();
          var height = matrix.getHeight();
          for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                  var arrayY = array[y]; // We can at least optimize this access
                  if (x + 6 < width &&
                      arrayY[x] === 1 &&
                      arrayY[x + 1] === 0 &&
                      arrayY[x + 2] === 1 &&
                      arrayY[x + 3] === 1 &&
                      arrayY[x + 4] === 1 &&
                      arrayY[x + 5] === 0 &&
                      arrayY[x + 6] === 1 &&
                      (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {
                      numPenalties++;
                  }
                  if (y + 6 < height &&
                      array[y][x] === 1 &&
                      array[y + 1][x] === 0 &&
                      array[y + 2][x] === 1 &&
                      array[y + 3][x] === 1 &&
                      array[y + 4][x] === 1 &&
                      array[y + 5][x] === 0 &&
                      array[y + 6][x] === 1 &&
                      (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {
                      numPenalties++;
                  }
              }
          }
          return numPenalties * MaskUtil.N3;
      };
      MaskUtil.isWhiteHorizontal = function (rowArray, from /*int*/, to /*int*/) {
          from = Math.max(from, 0);
          to = Math.min(to, rowArray.length);
          for (var i = from; i < to; i++) {
              if (rowArray[i] === 1) {
                  return false;
              }
          }
          return true;
      };
      MaskUtil.isWhiteVertical = function (array, col /*int*/, from /*int*/, to /*int*/) {
          from = Math.max(from, 0);
          to = Math.min(to, array.length);
          for (var i = from; i < to; i++) {
              if (array[i][col] === 1) {
                  return false;
              }
          }
          return true;
      };
      /**
       * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
       * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
       */
      MaskUtil.applyMaskPenaltyRule4 = function (matrix) {
          var numDarkCells = 0;
          var array = matrix.getArray();
          var width = matrix.getWidth();
          var height = matrix.getHeight();
          for (var y = 0; y < height; y++) {
              var arrayY = array[y];
              for (var x = 0; x < width; x++) {
                  if (arrayY[x] === 1) {
                      numDarkCells++;
                  }
              }
          }
          var numTotalCells = matrix.getHeight() * matrix.getWidth();
          var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
          return fivePercentVariances * MaskUtil.N4;
      };
      /**
       * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask
       * pattern conditions.
       */
      MaskUtil.getDataMaskBit = function (maskPattern /*int*/, x /*int*/, y /*int*/) {
          var intermediate; /*int*/
          var temp; /*int*/
          switch (maskPattern) {
              case 0:
                  intermediate = (y + x) & 0x1;
                  break;
              case 1:
                  intermediate = y & 0x1;
                  break;
              case 2:
                  intermediate = x % 3;
                  break;
              case 3:
                  intermediate = (y + x) % 3;
                  break;
              case 4:
                  intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;
                  break;
              case 5:
                  temp = y * x;
                  intermediate = (temp & 0x1) + (temp % 3);
                  break;
              case 6:
                  temp = y * x;
                  intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;
                  break;
              case 7:
                  temp = y * x;
                  intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;
                  break;
              default:
                  throw new IllegalArgumentException('Invalid mask pattern: ' + maskPattern);
          }
          return intermediate === 0;
      };
      /**
       * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
       * vertical and horizontal orders respectively.
       */
      MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {
          var penalty = 0;
          var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
          var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
          var array = matrix.getArray();
          for (var i = 0; i < iLimit; i++) {
              var numSameBitCells = 0;
              var prevBit = -1;
              for (var j = 0; j < jLimit; j++) {
                  var bit = isHorizontal ? array[i][j] : array[j][i];
                  if (bit === prevBit) {
                      numSameBitCells++;
                  }
                  else {
                      if (numSameBitCells >= 5) {
                          penalty += MaskUtil.N1 + (numSameBitCells - 5);
                      }
                      numSameBitCells = 1; // Include the cell itself.
                      prevBit = bit;
                  }
              }
              if (numSameBitCells >= 5) {
                  penalty += MaskUtil.N1 + (numSameBitCells - 5);
              }
          }
          return penalty;
      };
      // Penalty weights from section 6.8.2.1
      MaskUtil.N1 = 3;
      MaskUtil.N2 = 3;
      MaskUtil.N3 = 40;
      MaskUtil.N4 = 10;
      return MaskUtil;
  }());

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __values$B = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  /**
   * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned
   * -1, 0, and 1, I'm going to use less memory and go with bytes.
   *
   * @author dswitkin@google.com (Daniel Switkin)
   */
  var ByteMatrix = /** @class */ (function () {
      function ByteMatrix(width /*int*/, height /*int*/) {
          this.width = width;
          this.height = height;
          var bytes = new Array(height); // [height][width]
          for (var i = 0; i !== height; i++) {
              bytes[i] = new Uint8Array(width);
          }
          this.bytes = bytes;
      }
      ByteMatrix.prototype.getHeight = function () {
          return this.height;
      };
      ByteMatrix.prototype.getWidth = function () {
          return this.width;
      };
      ByteMatrix.prototype.get = function (x /*int*/, y /*int*/) {
          return this.bytes[y][x];
      };
      /**
       * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)
       */
      ByteMatrix.prototype.getArray = function () {
          return this.bytes;
      };
      // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside
      ByteMatrix.prototype.setNumber = function (x /*int*/, y /*int*/, value /*byte|int*/) {
          this.bytes[y][x] = value;
      };
      // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {
      //   bytes[y][x] = (byte) value
      // }
      ByteMatrix.prototype.setBoolean = function (x /*int*/, y /*int*/, value) {
          this.bytes[y][x] = /*(byte) */ (value ? 1 : 0);
      };
      ByteMatrix.prototype.clear = function (value /*byte*/) {
          var e_1, _a;
          try {
              for (var _b = __values$B(this.bytes), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var aByte = _c.value;
                  Arrays.fill(aByte, value);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      ByteMatrix.prototype.equals = function (o) {
          if (!(o instanceof ByteMatrix)) {
              return false;
          }
          var other = o;
          if (this.width !== other.width) {
              return false;
          }
          if (this.height !== other.height) {
              return false;
          }
          for (var y = 0, height = this.height; y < height; ++y) {
              var bytesY = this.bytes[y];
              var otherBytesY = other.bytes[y];
              for (var x = 0, width = this.width; x < width; ++x) {
                  if (bytesY[x] !== otherBytesY[x]) {
                      return false;
                  }
              }
          }
          return true;
      };
      /*@Override*/
      ByteMatrix.prototype.toString = function () {
          var result = new StringBuilder(); // (2 * width * height + 2)
          for (var y = 0, height = this.height; y < height; ++y) {
              var bytesY = this.bytes[y];
              for (var x = 0, width = this.width; x < width; ++x) {
                  switch (bytesY[x]) {
                      case 0:
                          result.append(' 0');
                          break;
                      case 1:
                          result.append(' 1');
                          break;
                      default:
                          result.append('  ');
                          break;
                  }
              }
              result.append('\n');
          }
          return result.toString();
      };
      return ByteMatrix;
  }());

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @author satorux@google.com (Satoru Takabayashi) - creator
   * @author dswitkin@google.com (Daniel Switkin) - ported from C++
   */
  var QRCode = /** @class */ (function () {
      function QRCode() {
          this.maskPattern = -1;
      }
      QRCode.prototype.getMode = function () {
          return this.mode;
      };
      QRCode.prototype.getECLevel = function () {
          return this.ecLevel;
      };
      QRCode.prototype.getVersion = function () {
          return this.version;
      };
      QRCode.prototype.getMaskPattern = function () {
          return this.maskPattern;
      };
      QRCode.prototype.getMatrix = function () {
          return this.matrix;
      };
      /*@Override*/
      QRCode.prototype.toString = function () {
          var result = new StringBuilder(); // (200)
          result.append('<<\n');
          result.append(' mode: ');
          result.append(this.mode ? this.mode.toString() : 'null');
          result.append('\n ecLevel: ');
          result.append(this.ecLevel ? this.ecLevel.toString() : 'null');
          result.append('\n version: ');
          result.append(this.version ? this.version.toString() : 'null');
          result.append('\n maskPattern: ');
          result.append(this.maskPattern.toString());
          if (this.matrix) {
              result.append('\n matrix:\n');
              result.append(this.matrix.toString());
          }
          else {
              result.append('\n matrix: null\n');
          }
          result.append('>>\n');
          return result.toString();
      };
      QRCode.prototype.setMode = function (value) {
          this.mode = value;
      };
      QRCode.prototype.setECLevel = function (value) {
          this.ecLevel = value;
      };
      QRCode.prototype.setVersion = function (version) {
          this.version = version;
      };
      QRCode.prototype.setMaskPattern = function (value /*int*/) {
          this.maskPattern = value;
      };
      QRCode.prototype.setMatrix = function (value) {
          this.matrix = value;
      };
      // Check if "mask_pattern" is valid.
      QRCode.isValidMaskPattern = function (maskPattern /*int*/) {
          return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
      };
      QRCode.NUM_MASK_PATTERNS = 8;
      return QRCode;
  }());

  var __extends$_ = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Custom Error class of type Exception.
   */
  var WriterException = /** @class */ (function (_super) {
      __extends$_(WriterException, _super);
      function WriterException() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      WriterException.kind = 'WriterException';
      return WriterException;
  }(Exception));

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @author satorux@google.com (Satoru Takabayashi) - creator
   * @author dswitkin@google.com (Daniel Switkin) - ported from C++
   */
  var MatrixUtil = /** @class */ (function () {
      function MatrixUtil() {
          // do nothing
      }
      // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).
      //
      // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding
      // with the ByteMatrix initialized all to zero.
      MatrixUtil.clearMatrix = function (matrix) {
          // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255
          matrix.clear(/*(byte) */ /*-1*/ 255);
      };
      // Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On
      // success, store the result in "matrix" and return true.
      MatrixUtil.buildMatrix = function (dataBits, ecLevel, version, maskPattern /*int*/, matrix) {
          MatrixUtil.clearMatrix(matrix);
          MatrixUtil.embedBasicPatterns(version, matrix);
          // Type information appear with any version.
          MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
          // Version info appear if version >= 7.
          MatrixUtil.maybeEmbedVersionInfo(version, matrix);
          // Data should be embedded at end.
          MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
      };
      // Embed basic patterns. On success, modify the matrix and return true.
      // The basic patterns are:
      // - Position detection patterns
      // - Timing patterns
      // - Dark dot at the left bottom corner
      // - Position adjustment patterns, if need be
      MatrixUtil.embedBasicPatterns = function (version, matrix) {
          // Let's get started with embedding big squares at corners.
          MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
          // Then, embed the dark dot at the left bottom corner.
          MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
          // Position adjustment patterns appear if version >= 2.
          MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);
          // Timing patterns should be embedded after position adj. patterns.
          MatrixUtil.embedTimingPatterns(matrix);
      };
      // Embed type information. On success, modify the matrix.
      MatrixUtil.embedTypeInfo = function (ecLevel, maskPattern /*int*/, matrix) {
          var typeInfoBits = new BitArray();
          MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
          for (var i = 0, size = typeInfoBits.getSize(); i < size; ++i) {
              // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in
              // "typeInfoBits".
              var bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);
              // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).
              var coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];
              var x1 = coordinates[0];
              var y1 = coordinates[1];
              matrix.setBoolean(x1, y1, bit);
              if (i < 8) {
                  // Right top corner.
                  var x2 = matrix.getWidth() - i - 1;
                  var y2 = 8;
                  matrix.setBoolean(x2, y2, bit);
              }
              else {
                  // Left bottom corner.
                  var x2 = 8;
                  var y2 = matrix.getHeight() - 7 + (i - 8);
                  matrix.setBoolean(x2, y2, bit);
              }
          }
      };
      // Embed version information if need be. On success, modify the matrix and return true.
      // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
      MatrixUtil.maybeEmbedVersionInfo = function (version, matrix) {
          if (version.getVersionNumber() < 7) { // Version info is necessary if version >= 7.
              return; // Don't need version info.
          }
          var versionInfoBits = new BitArray();
          MatrixUtil.makeVersionInfoBits(version, versionInfoBits);
          var bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.
          for (var i = 0; i < 6; ++i) {
              for (var j = 0; j < 3; ++j) {
                  // Place bits in LSB (least significant bit) to MSB order.
                  var bit = versionInfoBits.get(bitIndex);
                  bitIndex--;
                  // Left bottom corner.
                  matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);
                  // Right bottom corner.
                  matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);
              }
          }
      };
      // Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.
      // For debugging purposes, it skips masking process if "getMaskPattern" is -1(TYPESCRIPTPORT: 255).
      // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
      MatrixUtil.embedDataBits = function (dataBits, maskPattern /*int*/, matrix) {
          var bitIndex = 0;
          var direction = -1;
          // Start from the right bottom cell.
          var x = matrix.getWidth() - 1;
          var y = matrix.getHeight() - 1;
          while (x > 0) {
              // Skip the vertical timing pattern.
              if (x === 6) {
                  x -= 1;
              }
              while (y >= 0 && y < matrix.getHeight()) {
                  for (var i = 0; i < 2; ++i) {
                      var xx = x - i;
                      // Skip the cell if it's not empty.
                      if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {
                          continue;
                      }
                      var bit = void 0;
                      if (bitIndex < dataBits.getSize()) {
                          bit = dataBits.get(bitIndex);
                          ++bitIndex;
                      }
                      else {
                          // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described
                          // in 8.4.9 of JISX0510:2004 (p. 24).
                          bit = false;
                      }
                      // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).
                      if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {
                          bit = !bit;
                      }
                      matrix.setBoolean(xx, y, bit);
                  }
                  y += direction;
              }
              direction = -direction; // Reverse the direction.
              y += direction;
              x -= 2; // Move to the left.
          }
          // All bits should be consumed.
          if (bitIndex !== dataBits.getSize()) {
              throw new WriterException('Not all bits consumed: ' + bitIndex + '/' + dataBits.getSize());
          }
      };
      // Return the position of the most significant bit set (one: to) in the "value". The most
      // significant bit is position 32. If there is no bit set, return 0. Examples:
      // - findMSBSet(0) => 0
      // - findMSBSet(1) => 1
      // - findMSBSet(255) => 8
      MatrixUtil.findMSBSet = function (value /*int*/) {
          return 32 - Integer.numberOfLeadingZeros(value);
      };
      // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH
      // code is used for encoding type information and version information.
      // Example: Calculation of version information of 7.
      // f(x) is created from 7.
      //   - 7 = 000111 in 6 bits
      //   - f(x) = x^2 + x^1 + x^0
      // g(x) is given by the standard (p. 67)
      //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
      // Multiply f(x) by x^(18 - 6)
      //   - f'(x) = f(x) * x^(18 - 6)
      //   - f'(x) = x^14 + x^13 + x^12
      // Calculate the remainder of f'(x) / g(x)
      //         x^2
      //         __________________________________________________
      //   g(x) )x^14 + x^13 + x^12
      //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
      //         --------------------------------------------------
      //                              x^11 + x^10 + x^7 + x^4 + x^2
      //
      // The remainder is x^11 + x^10 + x^7 + x^4 + x^2
      // Encode it in binary: 110010010100
      // The return value is 0xc94 (1100 1001 0100)
      //
      // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
      // operations. We don't care if coefficients are positive or negative.
      MatrixUtil.calculateBCHCode = function (value /*int*/, poly /*int*/) {
          if (poly === 0) {
              throw new IllegalArgumentException('0 polynomial');
          }
          // If poly is "1 1111 0010 0101" (version info poly), msbSetInPoly is 13. We'll subtract 1
          // from 13 to make it 12.
          var msbSetInPoly = MatrixUtil.findMSBSet(poly);
          value <<= msbSetInPoly - 1;
          // Do the division business using exclusive-or operations.
          while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {
              value ^= poly << (MatrixUtil.findMSBSet(value) - msbSetInPoly);
          }
          // Now the "value" is the remainder (i.e. the BCH code)
          return value;
      };
      // Make bit vector of type information. On success, store the result in "bits" and return true.
      // Encode error correction level and mask pattern. See 8.9 of
      // JISX0510:2004 (p.45) for details.
      MatrixUtil.makeTypeInfoBits = function (ecLevel, maskPattern /*int*/, bits) {
          if (!QRCode.isValidMaskPattern(maskPattern)) {
              throw new WriterException('Invalid mask pattern');
          }
          var typeInfo = (ecLevel.getBits() << 3) | maskPattern;
          bits.appendBits(typeInfo, 5);
          var bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
          bits.appendBits(bchCode, 10);
          var maskBits = new BitArray();
          maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
          bits.xor(maskBits);
          if (bits.getSize() !== 15) { // Just in case.
              throw new WriterException('should not happen but we got: ' + bits.getSize());
          }
      };
      // Make bit vector of version information. On success, store the result in "bits" and return true.
      // See 8.10 of JISX0510:2004 (p.45) for details.
      MatrixUtil.makeVersionInfoBits = function (version, bits) {
          bits.appendBits(version.getVersionNumber(), 6);
          var bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
          bits.appendBits(bchCode, 12);
          if (bits.getSize() !== 18) { // Just in case.
              throw new WriterException('should not happen but we got: ' + bits.getSize());
          }
      };
      // Check if "value" is empty.
      MatrixUtil.isEmpty = function (value /*int*/) {
          return value === 255; // -1
      };
      MatrixUtil.embedTimingPatterns = function (matrix) {
          // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical
          // separation patterns (1: size). Thus, 8 = 7 + 1.
          for (var i = 8; i < matrix.getWidth() - 8; ++i) {
              var bit = (i + 1) % 2;
              // Horizontal line.
              if (MatrixUtil.isEmpty(matrix.get(i, 6))) {
                  matrix.setNumber(i, 6, bit);
              }
              // Vertical line.
              if (MatrixUtil.isEmpty(matrix.get(6, i))) {
                  matrix.setNumber(6, i, bit);
              }
          }
      };
      // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
      MatrixUtil.embedDarkDotAtLeftBottomCorner = function (matrix) {
          if (matrix.get(8, matrix.getHeight() - 8) === 0) {
              throw new WriterException();
          }
          matrix.setNumber(8, matrix.getHeight() - 8, 1);
      };
      MatrixUtil.embedHorizontalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
          for (var x = 0; x < 8; ++x) {
              if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {
                  throw new WriterException();
              }
              matrix.setNumber(xStart + x, yStart, 0);
          }
      };
      MatrixUtil.embedVerticalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
          for (var y = 0; y < 7; ++y) {
              if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {
                  throw new WriterException();
              }
              matrix.setNumber(xStart, yStart + y, 0);
          }
      };
      MatrixUtil.embedPositionAdjustmentPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
          for (var y = 0; y < 5; ++y) {
              var patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];
              for (var x = 0; x < 5; ++x) {
                  matrix.setNumber(xStart + x, yStart + y, patternY[x]);
              }
          }
      };
      MatrixUtil.embedPositionDetectionPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
          for (var y = 0; y < 7; ++y) {
              var patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];
              for (var x = 0; x < 7; ++x) {
                  matrix.setNumber(xStart + x, yStart + y, patternY[x]);
              }
          }
      };
      // Embed position detection patterns and surrounding vertical/horizontal separators.
      MatrixUtil.embedPositionDetectionPatternsAndSeparators = function (matrix) {
          // Embed three big squares at corners.
          var pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
          // Left top corner.
          MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
          // Right top corner.
          MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
          // Left bottom corner.
          MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
          // Embed horizontal separation patterns around the squares.
          var hspWidth = 8;
          // Left top corner.
          MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
          // Right top corner.
          MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
          // Left bottom corner.
          MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
          // Embed vertical separation patterns around the squares.
          var vspSize = 7;
          // Left top corner.
          MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
          // Right top corner.
          MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
          // Left bottom corner.
          MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
      };
      // Embed position adjustment patterns if need be.
      MatrixUtil.maybeEmbedPositionAdjustmentPatterns = function (version, matrix) {
          if (version.getVersionNumber() < 2) { // The patterns appear if version >= 2
              return;
          }
          var index = version.getVersionNumber() - 1;
          var coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
          for (var i = 0, length_1 = coordinates.length; i !== length_1; i++) {
              var y = coordinates[i];
              if (y >= 0) {
                  for (var j = 0; j !== length_1; j++) {
                      var x = coordinates[j];
                      if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {
                          // If the cell is unset, we embed the position adjustment pattern here.
                          // -2 is necessary since the x/y coordinates point to the center of the pattern, not the
                          // left top corner.
                          MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
                      }
                  }
              }
          }
      };
      MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
          Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
          Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
          Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
          Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
          Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
          Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
          Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
      ]);
      MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
          Int32Array.from([1, 1, 1, 1, 1]),
          Int32Array.from([1, 0, 0, 0, 1]),
          Int32Array.from([1, 0, 1, 0, 1]),
          Int32Array.from([1, 0, 0, 0, 1]),
          Int32Array.from([1, 1, 1, 1, 1]),
      ]);
      // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.
      MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
          Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
          Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
          Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
          Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
          Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
          Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
          Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
          Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
          Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
          Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
          Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
          Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
          Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
          Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
          Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
          Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
          Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
          Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
          Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
          Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
          Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
          Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
          Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
          Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
          Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
          Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
          Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
          Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
          Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
          Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
          Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
          Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
          Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
          Int32Array.from([6, 30, 58, 86, 114, 142, 170]),
      ]);
      // Type info cells at the left top corner.
      MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
          Int32Array.from([8, 0]),
          Int32Array.from([8, 1]),
          Int32Array.from([8, 2]),
          Int32Array.from([8, 3]),
          Int32Array.from([8, 4]),
          Int32Array.from([8, 5]),
          Int32Array.from([8, 7]),
          Int32Array.from([8, 8]),
          Int32Array.from([7, 8]),
          Int32Array.from([5, 8]),
          Int32Array.from([4, 8]),
          Int32Array.from([3, 8]),
          Int32Array.from([2, 8]),
          Int32Array.from([1, 8]),
          Int32Array.from([0, 8]),
      ]);
      // From Appendix D in JISX0510:2004 (p. 67)
      MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101
      // From Appendix C in JISX0510:2004 (p.65).
      MatrixUtil.TYPE_INFO_POLY = 0x537;
      MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;
      return MatrixUtil;
  }());

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /*namespace com.google.zxing.qrcode.encoder {*/
  var BlockPair = /** @class */ (function () {
      function BlockPair(dataBytes, errorCorrectionBytes) {
          this.dataBytes = dataBytes;
          this.errorCorrectionBytes = errorCorrectionBytes;
      }
      BlockPair.prototype.getDataBytes = function () {
          return this.dataBytes;
      };
      BlockPair.prototype.getErrorCorrectionBytes = function () {
          return this.errorCorrectionBytes;
      };
      return BlockPair;
  }());

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __values$C = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  /*import java.io.UnsupportedEncodingException;*/
  /*import java.util.ArrayList;*/
  /*import java.util.Collection;*/
  /*import java.util.Map;*/
  /**
   * @author satorux@google.com (Satoru Takabayashi) - creator
   * @author dswitkin@google.com (Daniel Switkin) - ported from C++
   */
  var Encoder = /** @class */ (function () {
      // TYPESCRIPTPORT: changed to UTF8, the default for js
      function Encoder() {
      }
      // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.
      // Basically it applies four rules and summate all penalties.
      Encoder.calculateMaskPenalty = function (matrix) {
          return MaskUtil.applyMaskPenaltyRule1(matrix)
              + MaskUtil.applyMaskPenaltyRule2(matrix)
              + MaskUtil.applyMaskPenaltyRule3(matrix)
              + MaskUtil.applyMaskPenaltyRule4(matrix);
      };
      /**
       * @param content text to encode
       * @param ecLevel error correction level to use
       * @return {@link QRCode} representing the encoded QR code
       * @throws WriterException if encoding can't succeed, because of for example invalid content
       *   or configuration
       */
      // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {
      //   return encode(content, ecLevel, null)
      // }
      Encoder.encode = function (content, ecLevel, hints) {
          if (hints === void 0) { hints = null; }
          // Determine what character encoding has been specified by the caller, if any
          var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;
          var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType$1.CHARACTER_SET);
          if (hasEncodingHint) {
              encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();
          }
          // Pick an encoding mode appropriate for the content. Note that this will not attempt to use
          // multiple modes / segments even if that were more efficient. Twould be nice.
          var mode = this.chooseMode(content, encoding);
          // This will store the header information, like mode and
          // length, as well as "header" segments like an ECI segment.
          var headerBits = new BitArray();
          // Append ECI segment if applicable
          if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
              var eci = CharacterSetECI.getCharacterSetECIByName(encoding);
              if (eci !== undefined) {
                  this.appendECI(eci, headerBits);
              }
          }
          // (With ECI in place,) Write the mode marker
          this.appendModeInfo(mode, headerBits);
          // Collect data within the main segment, separately, to count its size if needed. Don't add it to
          // main payload yet.
          var dataBits = new BitArray();
          this.appendBytes(content, mode, dataBits, encoding);
          var version;
          if (hints !== null && undefined !== hints.get(EncodeHintType$1.QR_VERSION)) {
              var versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);
              version = Version$1.getVersionForNumber(versionNumber);
              var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
              if (!this.willFit(bitsNeeded, version, ecLevel)) {
                  throw new WriterException('Data too big for requested version');
              }
          }
          else {
              version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
          }
          var headerAndDataBits = new BitArray();
          headerAndDataBits.appendBitArray(headerBits);
          // Find "length" of main segment and write it
          var numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;
          this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
          // Put data together into the overall payload
          headerAndDataBits.appendBitArray(dataBits);
          var ecBlocks = version.getECBlocksForLevel(ecLevel);
          var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
          // Terminate the bits properly.
          this.terminateBits(numDataBytes, headerAndDataBits);
          // Interleave data bits with error correction code.
          var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
          var qrCode = new QRCode();
          qrCode.setECLevel(ecLevel);
          qrCode.setMode(mode);
          qrCode.setVersion(version);
          //  Choose the mask pattern and set to "qrCode".
          var dimension = version.getDimensionForVersion();
          var matrix = new ByteMatrix(dimension, dimension);
          var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
          qrCode.setMaskPattern(maskPattern);
          // Build the matrix and set it to "qrCode".
          MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
          qrCode.setMatrix(matrix);
          return qrCode;
      };
      /**
       * Decides the smallest version of QR code that will contain all of the provided data.
       *
       * @throws WriterException if the data cannot fit in any version
       */
      Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {
          // Hard part: need to know version to know how many bits length takes. But need to know how many
          // bits it takes to know version. First we take a guess at version by assuming version will be
          // the minimum, 1:
          var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));
          var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
          // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.
          var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
          return this.chooseVersion(bitsNeeded, ecLevel);
      };
      Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {
          return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
      };
      /**
       * @return the code point of the table used in alphanumeric mode or
       *  -1 if there is no corresponding code in the table.
       */
      Encoder.getAlphanumericCode = function (code /*int*/) {
          if (code < Encoder.ALPHANUMERIC_TABLE.length) {
              return Encoder.ALPHANUMERIC_TABLE[code];
          }
          return -1;
      };
      // public static chooseMode(content: string): Mode {
      //   return chooseMode(content, null);
      // }
      /**
       * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
       * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
       */
      Encoder.chooseMode = function (content, encoding) {
          if (encoding === void 0) { encoding = null; }
          if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
              // Choose Kanji mode if all input are double-byte characters
              return Mode$1.KANJI;
          }
          var hasNumeric = false;
          var hasAlphanumeric = false;
          for (var i = 0, length_1 = content.length; i < length_1; ++i) {
              var c = content.charAt(i);
              if (Encoder.isDigit(c)) {
                  hasNumeric = true;
              }
              else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {
                  hasAlphanumeric = true;
              }
              else {
                  return Mode$1.BYTE;
              }
          }
          if (hasAlphanumeric) {
              return Mode$1.ALPHANUMERIC;
          }
          if (hasNumeric) {
              return Mode$1.NUMERIC;
          }
          return Mode$1.BYTE;
      };
      Encoder.isOnlyDoubleByteKanji = function (content) {
          var bytes;
          try {
              bytes = StringEncoding.encode(content, CharacterSetECI.SJIS); // content.getBytes("Shift_JIS"))
          }
          catch (ignored /*: UnsupportedEncodingException*/) {
              return false;
          }
          var length = bytes.length;
          if (length % 2 !== 0) {
              return false;
          }
          for (var i = 0; i < length; i += 2) {
              var byte1 = bytes[i] & 0xFF;
              if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {
                  return false;
              }
          }
          return true;
      };
      Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {
          var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.
          var bestMaskPattern = -1;
          // We try all mask patterns to choose the best one.
          for (var maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {
              MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
              var penalty = this.calculateMaskPenalty(matrix);
              if (penalty < minPenalty) {
                  minPenalty = penalty;
                  bestMaskPattern = maskPattern;
              }
          }
          return bestMaskPattern;
      };
      Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {
          for (var versionNum = 1; versionNum <= 40; versionNum++) {
              var version = Version$1.getVersionForNumber(versionNum);
              if (Encoder.willFit(numInputBits, version, ecLevel)) {
                  return version;
              }
          }
          throw new WriterException('Data too big');
      };
      /**
       * @return true if the number of input bits will fit in a code with the specified version and
       * error correction level.
       */
      Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {
          // In the following comments, we use numbers of Version 7-H.
          // numBytes = 196
          var numBytes = version.getTotalCodewords();
          // getNumECBytes = 130
          var ecBlocks = version.getECBlocksForLevel(ecLevel);
          var numEcBytes = ecBlocks.getTotalECCodewords();
          // getNumDataBytes = 196 - 130 = 66
          var numDataBytes = numBytes - numEcBytes;
          var totalInputBytes = (numInputBits + 7) / 8;
          return numDataBytes >= totalInputBytes;
      };
      /**
       * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
       */
      Encoder.terminateBits = function (numDataBytes /*int*/, bits) {
          var capacity = numDataBytes * 8;
          if (bits.getSize() > capacity) {
              throw new WriterException('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +
                  capacity);
          }
          for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {
              bits.appendBit(false);
          }
          // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.
          // If the last byte isn't 8-bit aligned, we'll add padding bits.
          var numBitsInLastByte = bits.getSize() & 0x07;
          if (numBitsInLastByte > 0) {
              for (var i = numBitsInLastByte; i < 8; i++) {
                  bits.appendBit(false);
              }
          }
          // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).
          var numPaddingBytes = numDataBytes - bits.getSizeInBytes();
          for (var i = 0; i < numPaddingBytes; ++i) {
              bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);
          }
          if (bits.getSize() !== capacity) {
              throw new WriterException('Bits size does not equal capacity');
          }
      };
      /**
       * Get number of data bytes and number of error correction bytes for block id "blockID". Store
       * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
       * JISX0510:2004 (p.30)
       */
      Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {
          if (blockID >= numRSBlocks) {
              throw new WriterException('Block ID too large');
          }
          // numRsBlocksInGroup2 = 196 % 5 = 1
          var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
          // numRsBlocksInGroup1 = 5 - 1 = 4
          var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
          // numTotalBytesInGroup1 = 196 / 5 = 39
          var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
          // numTotalBytesInGroup2 = 39 + 1 = 40
          var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
          // numDataBytesInGroup1 = 66 / 5 = 13
          var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
          // numDataBytesInGroup2 = 13 + 1 = 14
          var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
          // numEcBytesInGroup1 = 39 - 13 = 26
          var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
          // numEcBytesInGroup2 = 40 - 14 = 26
          var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
          // Sanity checks.
          // 26 = 26
          if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
              throw new WriterException('EC bytes mismatch');
          }
          // 5 = 4 + 1.
          if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
              throw new WriterException('RS blocks mismatch');
          }
          // 196 = (13 + 26) * 4 + (14 + 26) * 1
          if (numTotalBytes !==
              ((numDataBytesInGroup1 + numEcBytesInGroup1) *
                  numRsBlocksInGroup1) +
                  ((numDataBytesInGroup2 + numEcBytesInGroup2) *
                      numRsBlocksInGroup2)) {
              throw new WriterException('Total bytes mismatch');
          }
          if (blockID < numRsBlocksInGroup1) {
              numDataBytesInBlock[0] = numDataBytesInGroup1;
              numECBytesInBlock[0] = numEcBytesInGroup1;
          }
          else {
              numDataBytesInBlock[0] = numDataBytesInGroup2;
              numECBytesInBlock[0] = numEcBytesInGroup2;
          }
      };
      /**
       * Interleave "bits" with corresponding error correction bytes. On success, store the result in
       * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
       */
      Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {
          var e_1, _a, e_2, _b;
          // "bits" must have "getNumDataBytes" bytes of data.
          if (bits.getSizeInBytes() !== numDataBytes) {
              throw new WriterException('Number of bits and data bytes does not match');
          }
          // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll
          // store the divided data bytes blocks and error correction bytes blocks into "blocks".
          var dataBytesOffset = 0;
          var maxNumDataBytes = 0;
          var maxNumEcBytes = 0;
          // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.
          var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)
          for (var i = 0; i < numRSBlocks; ++i) {
              var numDataBytesInBlock = new Int32Array(1);
              var numEcBytesInBlock = new Int32Array(1);
              Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);
              var size = numDataBytesInBlock[0];
              var dataBytes = new Uint8Array(size);
              bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
              var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);
              blocks.push(new BlockPair(dataBytes, ecBytes));
              maxNumDataBytes = Math.max(maxNumDataBytes, size);
              maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
              dataBytesOffset += numDataBytesInBlock[0];
          }
          if (numDataBytes !== dataBytesOffset) {
              throw new WriterException('Data bytes does not match offset');
          }
          var result = new BitArray();
          // First, place data blocks.
          for (var i = 0; i < maxNumDataBytes; ++i) {
              try {
                  for (var blocks_1 = (e_1 = void 0, __values$C(blocks)), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {
                      var block = blocks_1_1.value;
                      var dataBytes = block.getDataBytes();
                      if (i < dataBytes.length) {
                          result.appendBits(dataBytes[i], 8);
                      }
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          // Then, place error correction blocks.
          for (var i = 0; i < maxNumEcBytes; ++i) {
              try {
                  for (var blocks_2 = (e_2 = void 0, __values$C(blocks)), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {
                      var block = blocks_2_1.value;
                      var ecBytes = block.getErrorCorrectionBytes();
                      if (i < ecBytes.length) {
                          result.appendBits(ecBytes[i], 8);
                      }
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
          }
          if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.
              throw new WriterException('Interleaving error: ' + numTotalBytes + ' and ' +
                  result.getSizeInBytes() + ' differ.');
          }
          return result;
      };
      Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {
          var numDataBytes = dataBytes.length;
          var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]
          for (var i = 0; i < numDataBytes; i++) {
              toEncode[i] = dataBytes[i] & 0xFF;
          }
          new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
          var ecBytes = new Uint8Array(numEcBytesInBlock);
          for (var i = 0; i < numEcBytesInBlock; i++) {
              ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];
          }
          return ecBytes;
      };
      /**
       * Append mode info. On success, store the result in "bits".
       */
      Encoder.appendModeInfo = function (mode, bits) {
          bits.appendBits(mode.getBits(), 4);
      };
      /**
       * Append length info. On success, store the result in "bits".
       */
      Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {
          var numBits = mode.getCharacterCountBits(version);
          if (numLetters >= (1 << numBits)) {
              throw new WriterException(numLetters + ' is bigger than ' + ((1 << numBits) - 1));
          }
          bits.appendBits(numLetters, numBits);
      };
      /**
       * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
       */
      Encoder.appendBytes = function (content, mode, bits, encoding) {
          switch (mode) {
              case Mode$1.NUMERIC:
                  Encoder.appendNumericBytes(content, bits);
                  break;
              case Mode$1.ALPHANUMERIC:
                  Encoder.appendAlphanumericBytes(content, bits);
                  break;
              case Mode$1.BYTE:
                  Encoder.append8BitBytes(content, bits, encoding);
                  break;
              case Mode$1.KANJI:
                  Encoder.appendKanjiBytes(content, bits);
                  break;
              default:
                  throw new WriterException('Invalid mode: ' + mode);
          }
      };
      Encoder.getDigit = function (singleCharacter) {
          return singleCharacter.charCodeAt(0) - 48;
      };
      Encoder.isDigit = function (singleCharacter) {
          var cn = Encoder.getDigit(singleCharacter);
          return cn >= 0 && cn <= 9;
      };
      Encoder.appendNumericBytes = function (content, bits) {
          var length = content.length;
          var i = 0;
          while (i < length) {
              var num1 = Encoder.getDigit(content.charAt(i));
              if (i + 2 < length) {
                  // Encode three numeric letters in ten bits.
                  var num2 = Encoder.getDigit(content.charAt(i + 1));
                  var num3 = Encoder.getDigit(content.charAt(i + 2));
                  bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
                  i += 3;
              }
              else if (i + 1 < length) {
                  // Encode two numeric letters in seven bits.
                  var num2 = Encoder.getDigit(content.charAt(i + 1));
                  bits.appendBits(num1 * 10 + num2, 7);
                  i += 2;
              }
              else {
                  // Encode one numeric letter in four bits.
                  bits.appendBits(num1, 4);
                  i++;
              }
          }
      };
      Encoder.appendAlphanumericBytes = function (content, bits) {
          var length = content.length;
          var i = 0;
          while (i < length) {
              var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));
              if (code1 === -1) {
                  throw new WriterException();
              }
              if (i + 1 < length) {
                  var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));
                  if (code2 === -1) {
                      throw new WriterException();
                  }
                  // Encode two alphanumeric letters in 11 bits.
                  bits.appendBits(code1 * 45 + code2, 11);
                  i += 2;
              }
              else {
                  // Encode one alphanumeric letter in six bits.
                  bits.appendBits(code1, 6);
                  i++;
              }
          }
      };
      Encoder.append8BitBytes = function (content, bits, encoding) {
          var bytes;
          try {
              bytes = StringEncoding.encode(content, encoding);
          }
          catch (uee /*: UnsupportedEncodingException*/) {
              throw new WriterException(uee);
          }
          for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {
              var b = bytes[i];
              bits.appendBits(b, 8);
          }
      };
      /**
       * @throws WriterException
       */
      Encoder.appendKanjiBytes = function (content, bits) {
          var bytes;
          try {
              bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
          }
          catch (uee /*: UnsupportedEncodingException*/) {
              throw new WriterException(uee);
          }
          var length = bytes.length;
          for (var i = 0; i < length; i += 2) {
              var byte1 = bytes[i] & 0xFF;
              var byte2 = bytes[i + 1] & 0xFF;
              var code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;
              var subtracted = -1;
              if (code >= 0x8140 && code <= 0x9ffc) {
                  subtracted = code - 0x8140;
              }
              else if (code >= 0xe040 && code <= 0xebbf) {
                  subtracted = code - 0xc140;
              }
              if (subtracted === -1) {
                  throw new WriterException('Invalid byte sequence');
              }
              var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);
              bits.appendBits(encoded, 13);
          }
      };
      Encoder.appendECI = function (eci, bits) {
          bits.appendBits(Mode$1.ECI.getBits(), 4);
          // This is correct for values up to 127, which is all we need now.
          bits.appendBits(eci.getValue(), 8);
      };
      // The original table is defined in the table 5 of JISX0510:2004 (p.19).
      Encoder.ALPHANUMERIC_TABLE = Int32Array.from([
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,
          -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
          25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
      ]);
      Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName(); // "ISO-8859-1"
      return Encoder;
  }());

  /*
   * Copyright 2008 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /*import java.util.Map;*/
  /**
   * This object renders a QR Code as a BitMatrix 2D array of greyscale values.
   *
   * @author dswitkin@google.com (Daniel Switkin)
   */
  var QRCodeWriter = /** @class */ (function () {
      function QRCodeWriter() {
      }
      /*@Override*/
      // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix
      //     /*throws WriterException */ {
      //   return encode(contents, format, width, height, null)
      // }
      /*@Override*/
      QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {
          if (contents.length === 0) {
              throw new IllegalArgumentException('Found empty contents');
          }
          if (format !== BarcodeFormat$1.QR_CODE) {
              throw new IllegalArgumentException('Can only encode QR_CODE, but got ' + format);
          }
          if (width < 0 || height < 0) {
              throw new IllegalArgumentException("Requested dimensions are too small: " + width + "x" + height);
          }
          var errorCorrectionLevel = ErrorCorrectionLevel.L;
          var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
          if (hints !== null) {
              if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
                  errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
              }
              if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {
                  quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
              }
          }
          var code = Encoder.encode(contents, errorCorrectionLevel, hints);
          return QRCodeWriter.renderResult(code, width, height, quietZone);
      };
      // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses
      // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
      QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {
          var input = code.getMatrix();
          if (input === null) {
              throw new IllegalStateException();
          }
          var inputWidth = input.getWidth();
          var inputHeight = input.getHeight();
          var qrWidth = inputWidth + (quietZone * 2);
          var qrHeight = inputHeight + (quietZone * 2);
          var outputWidth = Math.max(width, qrWidth);
          var outputHeight = Math.max(height, qrHeight);
          var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
          // Padding includes both the quiet zone and the extra white pixels to accommodate the requested
          // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.
          // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will
          // handle all the padding from 100x100 (the actual QR) up to 200x160.
          var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);
          var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);
          var output = new BitMatrix(outputWidth, outputHeight);
          for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
              // Write the contents of this row of the barcode
              for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                  if (input.get(inputX, inputY) === 1) {
                      output.setRegion(outputX, outputY, multiple, multiple);
                  }
              }
          }
          return output;
      };
      QRCodeWriter.QUIET_ZONE_SIZE = 4;
      return QRCodeWriter;
  }());

  /*
   * Copyright 2009 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __extends$$ = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * This object extends LuminanceSource around an array of YUV data returned from the camera driver,
   * with the option to crop to a rectangle within the full data. This can be used to exclude
   * superfluous pixels around the perimeter and speed up decoding.
   *
   * It works for any pixel format where the Y channel is planar and appears first, including
   * YCbCr_420_SP and YCbCr_422_SP.
   *
   * @author dswitkin@google.com (Daniel Switkin)
   */
  var PlanarYUVLuminanceSource = /** @class */ (function (_super) {
      __extends$$(PlanarYUVLuminanceSource, _super);
      function PlanarYUVLuminanceSource(yuvData, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/, width /*int*/, height /*int*/, reverseHorizontal) {
          var _this = _super.call(this, width, height) || this;
          _this.yuvData = yuvData;
          _this.dataWidth = dataWidth;
          _this.dataHeight = dataHeight;
          _this.left = left;
          _this.top = top;
          if (left + width > dataWidth || top + height > dataHeight) {
              throw new IllegalArgumentException('Crop rectangle does not fit within image data.');
          }
          if (reverseHorizontal) {
              _this.reverseHorizontal(width, height);
          }
          return _this;
      }
      /*@Override*/
      PlanarYUVLuminanceSource.prototype.getRow = function (y /*int*/, row) {
          if (y < 0 || y >= this.getHeight()) {
              throw new IllegalArgumentException('Requested row is outside the image: ' + y);
          }
          var width = this.getWidth();
          if (row === null || row === undefined || row.length < width) {
              row = new Uint8ClampedArray(width);
          }
          var offset = (y + this.top) * this.dataWidth + this.left;
          System.arraycopy(this.yuvData, offset, row, 0, width);
          return row;
      };
      /*@Override*/
      PlanarYUVLuminanceSource.prototype.getMatrix = function () {
          var width = this.getWidth();
          var height = this.getHeight();
          // If the caller asks for the entire underlying image, save the copy and give them the
          // original data. The docs specifically warn that result.length must be ignored.
          if (width === this.dataWidth && height === this.dataHeight) {
              return this.yuvData;
          }
          var area = width * height;
          var matrix = new Uint8ClampedArray(area);
          var inputOffset = this.top * this.dataWidth + this.left;
          // If the width matches the full width of the underlying data, perform a single copy.
          if (width === this.dataWidth) {
              System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
              return matrix;
          }
          // Otherwise copy one cropped row at a time.
          for (var y = 0; y < height; y++) {
              var outputOffset = y * width;
              System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
              inputOffset += this.dataWidth;
          }
          return matrix;
      };
      /*@Override*/
      PlanarYUVLuminanceSource.prototype.isCropSupported = function () {
          return true;
      };
      /*@Override*/
      PlanarYUVLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
          return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
      };
      PlanarYUVLuminanceSource.prototype.renderThumbnail = function () {
          var width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          var height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          var pixels = new Int32Array(width * height);
          var yuv = this.yuvData;
          var inputOffset = this.top * this.dataWidth + this.left;
          for (var y = 0; y < height; y++) {
              var outputOffset = y * width;
              for (var x = 0; x < width; x++) {
                  var grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;
                  pixels[outputOffset + x] = 0xFF000000 | (grey * 0x00010101);
              }
              inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          }
          return pixels;
      };
      /**
       * @return width of image from {@link #renderThumbnail()}
       */
      PlanarYUVLuminanceSource.prototype.getThumbnailWidth = function () {
          return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      };
      /**
       * @return height of image from {@link #renderThumbnail()}
       */
      PlanarYUVLuminanceSource.prototype.getThumbnailHeight = function () {
          return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      };
      PlanarYUVLuminanceSource.prototype.reverseHorizontal = function (width /*int*/, height /*int*/) {
          var yuvData = this.yuvData;
          for (var y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
              var middle = rowStart + width / 2;
              for (var x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
                  var temp = yuvData[x1];
                  yuvData[x1] = yuvData[x2];
                  yuvData[x2] = temp;
              }
          }
      };
      PlanarYUVLuminanceSource.prototype.invert = function () {
          return new InvertedLuminanceSource(this);
      };
      PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;
      return PlanarYUVLuminanceSource;
  }(LuminanceSource));

  /*
   * Copyright 2009 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __extends$10 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * This class is used to help decode images from files which arrive as RGB data from
   * an ARGB pixel array. It does not support rotation.
   *
   * @author dswitkin@google.com (Daniel Switkin)
   * @author Betaminos
   */
  var RGBLuminanceSource = /** @class */ (function (_super) {
      __extends$10(RGBLuminanceSource, _super);
      function RGBLuminanceSource(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {
          var _this = _super.call(this, width, height) || this;
          _this.dataWidth = dataWidth;
          _this.dataHeight = dataHeight;
          _this.left = left;
          _this.top = top;
          if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array
              var size = width * height;
              var luminancesUint8Array = new Uint8ClampedArray(size);
              for (var offset = 0; offset < size; offset++) {
                  var pixel = luminances[offset];
                  var r = (pixel >> 16) & 0xff; // red
                  var g2 = (pixel >> 7) & 0x1fe; // 2 * green
                  var b = pixel & 0xff; // blue
                  // Calculate green-favouring average cheaply
                  luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;
              }
              _this.luminances = luminancesUint8Array;
          }
          else {
              _this.luminances = luminances;
          }
          if (undefined === dataWidth) {
              _this.dataWidth = width;
          }
          if (undefined === dataHeight) {
              _this.dataHeight = height;
          }
          if (undefined === left) {
              _this.left = 0;
          }
          if (undefined === top) {
              _this.top = 0;
          }
          if (_this.left + width > _this.dataWidth || _this.top + height > _this.dataHeight) {
              throw new IllegalArgumentException('Crop rectangle does not fit within image data.');
          }
          return _this;
      }
      /*@Override*/
      RGBLuminanceSource.prototype.getRow = function (y /*int*/, row) {
          if (y < 0 || y >= this.getHeight()) {
              throw new IllegalArgumentException('Requested row is outside the image: ' + y);
          }
          var width = this.getWidth();
          if (row === null || row === undefined || row.length < width) {
              row = new Uint8ClampedArray(width);
          }
          var offset = (y + this.top) * this.dataWidth + this.left;
          System.arraycopy(this.luminances, offset, row, 0, width);
          return row;
      };
      /*@Override*/
      RGBLuminanceSource.prototype.getMatrix = function () {
          var width = this.getWidth();
          var height = this.getHeight();
          // If the caller asks for the entire underlying image, save the copy and give them the
          // original data. The docs specifically warn that result.length must be ignored.
          if (width === this.dataWidth && height === this.dataHeight) {
              return this.luminances;
          }
          var area = width * height;
          var matrix = new Uint8ClampedArray(area);
          var inputOffset = this.top * this.dataWidth + this.left;
          // If the width matches the full width of the underlying data, perform a single copy.
          if (width === this.dataWidth) {
              System.arraycopy(this.luminances, inputOffset, matrix, 0, area);
              return matrix;
          }
          // Otherwise copy one cropped row at a time.
          for (var y = 0; y < height; y++) {
              var outputOffset = y * width;
              System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
              inputOffset += this.dataWidth;
          }
          return matrix;
      };
      /*@Override*/
      RGBLuminanceSource.prototype.isCropSupported = function () {
          return true;
      };
      /*@Override*/
      RGBLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
          return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
      };
      RGBLuminanceSource.prototype.invert = function () {
          return new InvertedLuminanceSource(this);
      };
      return RGBLuminanceSource;
  }(LuminanceSource));

  var __extends$11 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Just to make a shortcut between Java code and TS code.
   */
  var Charset = /** @class */ (function (_super) {
      __extends$11(Charset, _super);
      function Charset() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Charset.forName = function (name) {
          return this.getCharacterSetECIByName(name);
      };
      return Charset;
  }(CharacterSetECI));

  /**
   * Just to make a shortcut between Java code and TS code.
   */
  var StandardCharsets = /** @class */ (function () {
      function StandardCharsets() {
      }
      StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;
      return StandardCharsets;
  }());

  /*
  * Copyright 2013 ZXing authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  /**
   * Aztec 2D code representation
   *
   * @author Rustam Abdullaev
   */
  var AztecCode = /** @class */ (function () {
      function AztecCode() {
      }
      /**
       * @return {@code true} if compact instead of full mode
       */
      AztecCode.prototype.isCompact = function () {
          return this.compact;
      };
      AztecCode.prototype.setCompact = function (compact) {
          this.compact = compact;
      };
      /**
       * @return size in pixels (width and height)
       */
      AztecCode.prototype.getSize = function () {
          return this.size;
      };
      AztecCode.prototype.setSize = function (size) {
          this.size = size;
      };
      /**
       * @return number of levels
       */
      AztecCode.prototype.getLayers = function () {
          return this.layers;
      };
      AztecCode.prototype.setLayers = function (layers) {
          this.layers = layers;
      };
      /**
       * @return number of data codewords
       */
      AztecCode.prototype.getCodeWords = function () {
          return this.codeWords;
      };
      AztecCode.prototype.setCodeWords = function (codeWords) {
          this.codeWords = codeWords;
      };
      /**
       * @return the symbol image
       */
      AztecCode.prototype.getMatrix = function () {
          return this.matrix;
      };
      AztecCode.prototype.setMatrix = function (matrix) {
          this.matrix = matrix;
      };
      return AztecCode;
  }());

  var Collections = /** @class */ (function () {
      function Collections() {
      }
      /**
       * The singletonList(T) method is used to return an immutable list containing only the specified object.
       */
      Collections.singletonList = function (item) {
          return [item];
      };
      /**
       * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.
       */
      Collections.min = function (collection, comparator) {
          return collection.sort(comparator)[0];
      };
      return Collections;
  }());

  /*
  * Copyright 2013 ZXing authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var Token = /** @class */ (function () {
      function Token(previous) {
          this.previous = previous;
      }
      Token.prototype.getPrevious = function () {
          return this.previous;
      };
      return Token;
  }());

  /*
  * Copyright 2013 ZXing authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var __extends$12 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var SimpleToken = /** @class */ (function (_super) {
      __extends$12(SimpleToken, _super);
      function SimpleToken(previous, value, bitCount) {
          var _this = _super.call(this, previous) || this;
          _this.value = value;
          _this.bitCount = bitCount;
          return _this;
      }
      /**
       * @Override
       */
      SimpleToken.prototype.appendTo = function (bitArray, text) {
          bitArray.appendBits(this.value, this.bitCount);
      };
      SimpleToken.prototype.add = function (value, bitCount) {
          return new SimpleToken(this, value, bitCount);
      };
      SimpleToken.prototype.addBinaryShift = function (start, byteCount) {
          // no-op can't binary shift a simple token
          console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token');
          return new SimpleToken(this, start, byteCount);
      };
      /**
       * @Override
       */
      SimpleToken.prototype.toString = function () {
          var value = this.value & ((1 << this.bitCount) - 1);
          value |= 1 << this.bitCount;
          return '<' + Integer.toBinaryString(value | (1 << this.bitCount)).substring(1) + '>';
      };
      return SimpleToken;
  }(Token));

  /*
  * Copyright 2013 ZXing authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var __extends$13 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var BinaryShiftToken = /** @class */ (function (_super) {
      __extends$13(BinaryShiftToken, _super);
      function BinaryShiftToken(previous, binaryShiftStart, binaryShiftByteCount) {
          var _this = _super.call(this, previous, 0, 0) || this;
          _this.binaryShiftStart = binaryShiftStart;
          _this.binaryShiftByteCount = binaryShiftByteCount;
          return _this;
      }
      /**
       * @Override
       */
      BinaryShiftToken.prototype.appendTo = function (bitArray, text) {
          for (var i = 0; i < this.binaryShiftByteCount; i++) {
              if (i === 0 || (i === 31 && this.binaryShiftByteCount <= 62)) {
                  // We need a header before the first character, and before
                  // character 31 when the total byte code is <= 62
                  bitArray.appendBits(31, 5); // BINARY_SHIFT
                  if (this.binaryShiftByteCount > 62) {
                      bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
                  }
                  else if (i === 0) {
                      // 1 <= binaryShiftByteCode <= 62
                      bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
                  }
                  else {
                      // 32 <= binaryShiftCount <= 62 and i == 31
                      bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
                  }
              }
              bitArray.appendBits(text[this.binaryShiftStart + i], 8);
          }
      };
      BinaryShiftToken.prototype.addBinaryShift = function (start, byteCount) {
          // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);
          return new BinaryShiftToken(this, start, byteCount);
      };
      /**
       * @Override
       */
      BinaryShiftToken.prototype.toString = function () {
          return '<' + this.binaryShiftStart + '::' + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + '>';
      };
      return BinaryShiftToken;
  }(SimpleToken));

  function addBinaryShift(token, start, byteCount) {
      // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);
      return new BinaryShiftToken(token, start, byteCount);
  }
  function add(token, value, bitCount) {
      return new SimpleToken(token, value, bitCount);
  }

  var /*final*/ MODE_NAMES = [
      'UPPER',
      'LOWER',
      'DIGIT',
      'MIXED',
      'PUNCT'
  ];
  var /*final*/ MODE_UPPER = 0; // 5 bits
  var /*final*/ MODE_LOWER = 1; // 5 bits
  var /*final*/ MODE_DIGIT = 2; // 4 bits
  var /*final*/ MODE_MIXED = 3; // 5 bits
  var /*final*/ MODE_PUNCT = 4; // 5 bits
  var EMPTY_TOKEN = new SimpleToken(null, 0, 0);

  // The Latch Table shows, for each pair of Modes, the optimal method for
  // getting from one mode to another.  In the worst possible case, this can
  // be up to 14 bits.  In the best possible case, we are already there!
  // The high half-word of each entry gives the number of bits.
  // The low half-word of each entry are the actual bits necessary to change
  var LATCH_TABLE = [
      Int32Array.from([
          0,
          (5 << 16) + 28,
          (5 << 16) + 30,
          (5 << 16) + 29,
          (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
          (9 << 16) + (30 << 4) + 14,
          0,
          (5 << 16) + 30,
          (5 << 16) + 29,
          (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
          (4 << 16) + 14,
          (9 << 16) + (14 << 5) + 28,
          0,
          (9 << 16) + (14 << 5) + 29,
          (14 << 16) + (14 << 10) + (29 << 5) + 30
          // DIGIT -> UPPER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
          (5 << 16) + 29,
          (5 << 16) + 28,
          (10 << 16) + (29 << 5) + 30,
          0,
          (5 << 16) + 30 // MIXED -> PUNCT
      ]),
      Int32Array.from([
          (5 << 16) + 31,
          (10 << 16) + (31 << 5) + 28,
          (10 << 16) + (31 << 5) + 30,
          (10 << 16) + (31 << 5) + 29,
          0
      ])
  ];

  var __values$D = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  function static_SHIFT_TABLE(SHIFT_TABLE) {
      var e_1, _a;
      try {
          for (var SHIFT_TABLE_1 = __values$D(SHIFT_TABLE), SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next(); !SHIFT_TABLE_1_1.done; SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next()) {
              var table = SHIFT_TABLE_1_1.value /*Int32Array*/;
              Arrays.fill(table, -1);
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (SHIFT_TABLE_1_1 && !SHIFT_TABLE_1_1.done && (_a = SHIFT_TABLE_1.return)) _a.call(SHIFT_TABLE_1);
          }
          finally { if (e_1) throw e_1.error; }
      }
      SHIFT_TABLE[MODE_UPPER][MODE_PUNCT] = 0;
      SHIFT_TABLE[MODE_LOWER][MODE_PUNCT] = 0;
      SHIFT_TABLE[MODE_LOWER][MODE_UPPER] = 28;
      SHIFT_TABLE[MODE_MIXED][MODE_PUNCT] = 0;
      SHIFT_TABLE[MODE_DIGIT][MODE_PUNCT] = 0;
      SHIFT_TABLE[MODE_DIGIT][MODE_UPPER] = 15;
      return SHIFT_TABLE;
  }
  var /*final*/ SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6)); // mode shift codes, per table

  /*
   * Copyright 2013 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __values$E = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  /**
   * State represents all information about a sequence necessary to generate the current output.
   * Note that a state is immutable.
   */
  var State = /** @class */ (function () {
      function State(token, mode, binaryBytes, bitCount) {
          this.token = token;
          this.mode = mode;
          this.binaryShiftByteCount = binaryBytes;
          this.bitCount = bitCount;
          // Make sure we match the token
          // int binaryShiftBitCount = (binaryShiftByteCount * 8) +
          //    (binaryShiftByteCount === 0 ? 0 :
          //     binaryShiftByteCount <= 31 ? 10 :
          //     binaryShiftByteCount <= 62 ? 20 : 21);
          // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;
      }
      State.prototype.getMode = function () {
          return this.mode;
      };
      State.prototype.getToken = function () {
          return this.token;
      };
      State.prototype.getBinaryShiftByteCount = function () {
          return this.binaryShiftByteCount;
      };
      State.prototype.getBitCount = function () {
          return this.bitCount;
      };
      // Create a new state representing this state with a latch to a (not
      // necessary different) mode, and then a code.
      State.prototype.latchAndAppend = function (mode, value) {
          // assert binaryShiftByteCount === 0;
          var bitCount = this.bitCount;
          var token = this.token;
          if (mode !== this.mode) {
              var latch = LATCH_TABLE[this.mode][mode];
              token = add(token, latch & 0xffff, latch >> 16);
              bitCount += latch >> 16;
          }
          var latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
          token = add(token, value, latchModeBitCount);
          return new State(token, mode, 0, bitCount + latchModeBitCount);
      };
      // Create a new state representing this state, with a temporary shift
      // to a different mode to output a single value.
      State.prototype.shiftAndAppend = function (mode, value) {
          // assert binaryShiftByteCount === 0 && this.mode !== mode;
          var token = this.token;
          var thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
          // Shifts exist only to UPPER and PUNCT, both with tokens size 5.
          token = add(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
          token = add(token, value, 5);
          return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
      };
      // Create a new state representing this state, but an additional character
      // output in Binary Shift mode.
      State.prototype.addBinaryShiftChar = function (index) {
          var token = this.token;
          var mode = this.mode;
          var bitCount = this.bitCount;
          if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
              // assert binaryShiftByteCount === 0;
              var latch = LATCH_TABLE[mode][MODE_UPPER];
              token = add(token, latch & 0xffff, latch >> 16);
              bitCount += latch >> 16;
              mode = MODE_UPPER;
          }
          var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31
              ? 18
              : this.binaryShiftByteCount === 62
                  ? 9
                  : 8;
          var result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
          if (result.binaryShiftByteCount === 2047 + 31) {
              // The string is as long as it's allowed to be.  We should end it.
              result = result.endBinaryShift(index + 1);
          }
          return result;
      };
      // Create the state identical to this one, but we are no longer in
      // Binary Shift mode.
      State.prototype.endBinaryShift = function (index) {
          if (this.binaryShiftByteCount === 0) {
              return this;
          }
          var token = this.token;
          token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);
          // assert token.getTotalBitCount() === this.bitCount;
          return new State(token, this.mode, 0, this.bitCount);
      };
      // Returns true if "this" state is better (equal: or) to be in than "that"
      // state under all possible circumstances.
      State.prototype.isBetterThanOrEqualTo = function (other) {
          var newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
          if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
              // add additional B/S encoding cost of other, if any
              newModeBitCount +=
                  State.calculateBinaryShiftCost(other) -
                      State.calculateBinaryShiftCost(this);
          }
          else if (this.binaryShiftByteCount > other.binaryShiftByteCount &&
              other.binaryShiftByteCount > 0) {
              // maximum possible additional cost (it: h)
              newModeBitCount += 10;
          }
          return newModeBitCount <= other.bitCount;
      };
      State.prototype.toBitArray = function (text) {
          var e_1, _a;
          // Reverse the tokens, so that they are in the order that they should
          // be output
          var symbols = [];
          for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
              symbols.unshift(token);
          }
          var bitArray = new BitArray();
          try {
              // Add each token to the result.
              for (var symbols_1 = __values$E(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {
                  var symbol = symbols_1_1.value;
                  symbol.appendTo(bitArray, text);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          // assert bitArray.getSize() === this.bitCount;
          return bitArray;
      };
      /**
       * @Override
       */
      State.prototype.toString = function () {
          return StringUtils.format('%s bits=%d bytes=%d', MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
      };
      State.calculateBinaryShiftCost = function (state) {
          if (state.binaryShiftByteCount > 62) {
              return 21; // B/S with extended length
          }
          if (state.binaryShiftByteCount > 31) {
              return 20; // two B/S
          }
          if (state.binaryShiftByteCount > 0) {
              return 10; // one B/S
          }
          return 0;
      };
      State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);
      return State;
  }());

  function static_CHAR_MAP(CHAR_MAP) {
      var spaceCharCode = StringUtils.getCharCode(' ');
      var pointCharCode = StringUtils.getCharCode('.');
      var commaCharCode = StringUtils.getCharCode(',');
      CHAR_MAP[MODE_UPPER][spaceCharCode] = 1;
      var zUpperCharCode = StringUtils.getCharCode('Z');
      var aUpperCharCode = StringUtils.getCharCode('A');
      for (var c = aUpperCharCode; c <= zUpperCharCode; c++) {
          CHAR_MAP[MODE_UPPER][c] = c - aUpperCharCode + 2;
      }
      CHAR_MAP[MODE_LOWER][spaceCharCode] = 1;
      var zLowerCharCode = StringUtils.getCharCode('z');
      var aLowerCharCode = StringUtils.getCharCode('a');
      for (var c = aLowerCharCode; c <= zLowerCharCode; c++) {
          CHAR_MAP[MODE_LOWER][c] = c - aLowerCharCode + 2;
      }
      CHAR_MAP[MODE_DIGIT][spaceCharCode] = 1;
      var nineCharCode = StringUtils.getCharCode('9');
      var zeroCharCode = StringUtils.getCharCode('0');
      for (var c = zeroCharCode; c <= nineCharCode; c++) {
          CHAR_MAP[MODE_DIGIT][c] = c - zeroCharCode + 2;
      }
      CHAR_MAP[MODE_DIGIT][commaCharCode] = 12;
      CHAR_MAP[MODE_DIGIT][pointCharCode] = 13;
      var mixedTable = [
          '\x00',
          ' ',
          '\x01',
          '\x02',
          '\x03',
          '\x04',
          '\x05',
          '\x06',
          '\x07',
          '\b',
          '\t',
          '\n',
          '\x0b',
          '\f',
          '\r',
          '\x1b',
          '\x1c',
          '\x1d',
          '\x1e',
          '\x1f',
          '@',
          '\\',
          '^',
          '_',
          '`',
          '|',
          '~',
          '\x7f'
      ];
      for (var i = 0; i < mixedTable.length; i++) {
          CHAR_MAP[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])] = i;
      }
      var punctTable = [
          '\x00',
          '\r',
          '\x00',
          '\x00',
          '\x00',
          '\x00',
          '!',
          '\'',
          '#',
          '$',
          '%',
          '&',
          '\'',
          '(',
          ')',
          '*',
          '+',
          ',',
          '-',
          '.',
          '/',
          ':',
          ';',
          '<',
          '=',
          '>',
          '?',
          '[',
          ']',
          '{',
          '}'
      ];
      for (var i = 0; i < punctTable.length; i++) {
          if (StringUtils.getCharCode(punctTable[i]) > 0) {
              CHAR_MAP[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])] = i;
          }
      }
      return CHAR_MAP;
  }
  var CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));

  /*
   * Copyright 2013 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __values$F = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  /**
   * This produces nearly optimal encodings of text into the first-level of
   * encoding used by Aztec code.
   *
   * It uses a dynamic algorithm.  For each prefix of the string, it determines
   * a set of encodings that could lead to this prefix.  We repeatedly add a
   * character and generate a new set of optimal encodings until we have read
   * through the entire input.
   *
   * @author Frank Yellin
   * @author Rustam Abdullaev
   */
  var HighLevelEncoder = /** @class */ (function () {
      function HighLevelEncoder(text) {
          this.text = text;
      }
      /**
       * @return text represented by this encoder encoded as a {@link BitArray}
       */
      HighLevelEncoder.prototype.encode = function () {
          var spaceCharCode = StringUtils.getCharCode(' ');
          var lineBreakCharCode = StringUtils.getCharCode('\n');
          var states = Collections.singletonList(State.INITIAL_STATE);
          for (var index = 0; index < this.text.length; index++) {
              var pairCode = void 0;
              var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;
              switch (this.text[index]) {
                  case StringUtils.getCharCode('\r'):
                      pairCode = nextChar === lineBreakCharCode ? 2 : 0;
                      break;
                  case StringUtils.getCharCode('.'):
                      pairCode = nextChar === spaceCharCode ? 3 : 0;
                      break;
                  case StringUtils.getCharCode(','):
                      pairCode = nextChar === spaceCharCode ? 4 : 0;
                      break;
                  case StringUtils.getCharCode(':'):
                      pairCode = nextChar === spaceCharCode ? 5 : 0;
                      break;
                  default:
                      pairCode = 0;
              }
              if (pairCode > 0) {
                  // We have one of the four special PUNCT pairs.  Treat them specially.
                  // Get a new set of states for the two new characters.
                  states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);
                  index++;
              }
              else {
                  // Get a new set of states for the new character.
                  states = this.updateStateListForChar(states, index);
              }
          }
          // We are left with a set of states.  Find the shortest one.
          var minState = Collections.min(states, function (a, b) {
              return a.getBitCount() - b.getBitCount();
          });
          // Convert it to a bit array, and return.
          return minState.toBitArray(this.text);
      };
      // We update a set of states for a new character by updating each state
      // for the new character, merging the results, and then removing the
      // non-optimal states.
      HighLevelEncoder.prototype.updateStateListForChar = function (states, index) {
          var e_1, _a;
          var result = [];
          try {
              for (var states_1 = __values$F(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {
                  var state = states_1_1.value /*State*/;
                  this.updateStateForChar(state, index, result);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (states_1_1 && !states_1_1.done && (_a = states_1.return)) _a.call(states_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return HighLevelEncoder.simplifyStates(result);
      };
      // Return a set of states that represent the possible ways of updating this
      // state for the next character.  The resulting set of states are added to
      // the "result" list.
      HighLevelEncoder.prototype.updateStateForChar = function (state, index, result) {
          var ch = (this.text[index] & 0xff);
          var charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
          var stateNoBinary = null;
          for (var mode /*int*/ = 0; mode <= MODE_PUNCT; mode++) {
              var charInMode = CHAR_MAP[mode][ch];
              if (charInMode > 0) {
                  if (stateNoBinary == null) {
                      // Only create stateNoBinary the first time it's required.
                      stateNoBinary = state.endBinaryShift(index);
                  }
                  // Try generating the character by latching to its mode
                  if (!charInCurrentTable ||
                      mode === state.getMode() ||
                      mode === MODE_DIGIT) {
                      // If the character is in the current table, we don't want to latch to
                      // any other mode except possibly digit (which uses only 4 bits).  Any
                      // other latch would be equally successful *after* this character, and
                      // so wouldn't save any bits.
                      var latchState = stateNoBinary.latchAndAppend(mode, charInMode);
                      result.push(latchState);
                  }
                  // Try generating the character by switching to its mode.
                  if (!charInCurrentTable &&
                      SHIFT_TABLE[state.getMode()][mode] >= 0) {
                      // It never makes sense to temporarily shift to another mode if the
                      // character exists in the current mode.  That can never save bits.
                      var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
                      result.push(shiftState);
                  }
              }
          }
          if (state.getBinaryShiftByteCount() > 0 ||
              CHAR_MAP[state.getMode()][ch] === 0) {
              // It's never worthwhile to go into binary shift mode if you're not already
              // in binary shift mode, and the character exists in your current mode.
              // That can never save bits over just outputting the char in the current mode.
              var binaryState = state.addBinaryShiftChar(index);
              result.push(binaryState);
          }
      };
      HighLevelEncoder.updateStateListForPair = function (states, index, pairCode) {
          var e_2, _a;
          var result = [];
          try {
              for (var states_2 = __values$F(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {
                  var state = states_2_1.value /*State*/;
                  this.updateStateForPair(state, index, pairCode, result);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (states_2_1 && !states_2_1.done && (_a = states_2.return)) _a.call(states_2);
              }
              finally { if (e_2) throw e_2.error; }
          }
          return this.simplifyStates(result);
      };
      HighLevelEncoder.updateStateForPair = function (state, index, pairCode, result) {
          var stateNoBinary = state.endBinaryShift(index);
          // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code
          result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
          if (state.getMode() !== MODE_PUNCT) {
              // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.
              // Every state except C.MODE_PUNCT (handled above) can shift
              result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
          }
          if (pairCode === 3 || pairCode === 4) {
              // both characters are in DIGITS.  Sometimes better to just add two digits
              var digitState = stateNoBinary
                  .latchAndAppend(MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT
                  .latchAndAppend(MODE_DIGIT, 1); // space in DIGIT
              result.push(digitState);
          }
          if (state.getBinaryShiftByteCount() > 0) {
              // It only makes sense to do the characters as binary if we're already
              // in binary mode.
              var binaryState = state
                  .addBinaryShiftChar(index)
                  .addBinaryShiftChar(index + 1);
              result.push(binaryState);
          }
      };
      HighLevelEncoder.simplifyStates = function (states) {
          var e_3, _a, e_4, _b;
          var result = [];
          try {
              for (var states_3 = __values$F(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {
                  var newState = states_3_1.value;
                  var add = true;
                  var _loop_1 = function (oldState) {
                      if (oldState.isBetterThanOrEqualTo(newState)) {
                          add = false;
                          return "break";
                      }
                      if (newState.isBetterThanOrEqualTo(oldState)) {
                          // iterator.remove();
                          result = result.filter(function (x) { return x !== oldState; }); // remove old state
                      }
                  };
                  try {
                      for (var result_1 = (e_4 = void 0, __values$F(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {
                          var oldState = result_1_1.value;
                          var state_1 = _loop_1(oldState);
                          if (state_1 === "break")
                              break;
                      }
                  }
                  catch (e_4_1) { e_4 = { error: e_4_1 }; }
                  finally {
                      try {
                          if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);
                      }
                      finally { if (e_4) throw e_4.error; }
                  }
                  if (add) {
                      result.push(newState);
                  }
              }
          }
          catch (e_3_1) { e_3 = { error: e_3_1 }; }
          finally {
              try {
                  if (states_3_1 && !states_3_1.done && (_a = states_3.return)) _a.call(states_3);
              }
              finally { if (e_3) throw e_3.error; }
          }
          return result;
      };
      return HighLevelEncoder;
  }());

  var __values$G = (undefined && undefined.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  /*
   * Copyright 2013 ZXing authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // package com.google.zxing.aztec.encoder;
  // import com.google.zxing.common.BitArray;
  // import com.google.zxing.common.BitMatrix;
  // import com.google.zxing.common.reedsolomon.GenericGF;
  // import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;
  /**
   * Generates Aztec 2D barcodes.
   *
   * @author Rustam Abdullaev
   */
  var Encoder$1 = /** @class */ (function () {
      function Encoder() {
      }
      /**
       * Encodes the given binary content as an Aztec symbol
       *
       * @param data input data string
       * @return Aztec symbol matrix with metadata
       */
      Encoder.encodeBytes = function (data) {
          return Encoder.encode(data, Encoder.DEFAULT_EC_PERCENT, Encoder.DEFAULT_AZTEC_LAYERS);
      };
      /**
       * Encodes the given binary content as an Aztec symbol
       *
       * @param data input data string
       * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,
       *                      a minimum of 23% + 3 words is recommended)
       * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers
       * @return Aztec symbol matrix with metadata
       */
      Encoder.encode = function (data, minECCPercent, userSpecifiedLayers) {
          // High-level encode
          var bits = new HighLevelEncoder(data).encode();
          // stuff bits and choose symbol size
          var eccBits = Integer.truncDivision((bits.getSize() * minECCPercent), 100) + 11;
          var totalSizeBits = bits.getSize() + eccBits;
          var compact;
          var layers;
          var totalBitsInLayer;
          var wordSize;
          var stuffedBits;
          if (userSpecifiedLayers !== Encoder.DEFAULT_AZTEC_LAYERS) {
              compact = userSpecifiedLayers < 0;
              layers = Math.abs(userSpecifiedLayers);
              if (layers > (compact ? Encoder.MAX_NB_BITS_COMPACT : Encoder.MAX_NB_BITS)) {
                  throw new IllegalArgumentException(StringUtils.format('Illegal value %s for layers', userSpecifiedLayers));
              }
              totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);
              wordSize = Encoder.WORD_SIZE[layers];
              var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);
              stuffedBits = Encoder.stuffBits(bits, wordSize);
              if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
                  throw new IllegalArgumentException('Data to large for user specified layer');
              }
              if (compact && stuffedBits.getSize() > wordSize * 64) {
                  // Compact format only allows 64 data words, though C4 can hold more words than that
                  throw new IllegalArgumentException('Data to large for user specified layer');
              }
          }
          else {
              wordSize = 0;
              stuffedBits = null;
              // We look at the possible table sizes in the order Compact1, Compact2, Compact3,
              // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)
              // is the same size, but has more data.
              for (var i /*int*/ = 0;; i++) {
                  if (i > Encoder.MAX_NB_BITS) {
                      throw new IllegalArgumentException('Data too large for an Aztec code');
                  }
                  compact = i <= 3;
                  layers = compact ? i + 1 : i;
                  totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);
                  if (totalSizeBits > totalBitsInLayer) {
                      continue;
                  }
                  // [Re]stuff the bits if this is the first opportunity, or if the
                  // wordSize has changed
                  if (stuffedBits == null || wordSize !== Encoder.WORD_SIZE[layers]) {
                      wordSize = Encoder.WORD_SIZE[layers];
                      stuffedBits = Encoder.stuffBits(bits, wordSize);
                  }
                  var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);
                  if (compact && stuffedBits.getSize() > wordSize * 64) {
                      // Compact format only allows 64 data words, though C4 can hold more words than that
                      continue;
                  }
                  if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
                      break;
                  }
              }
          }
          var messageBits = Encoder.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
          // generate mode message
          var messageSizeInWords = stuffedBits.getSize() / wordSize;
          var modeMessage = Encoder.generateModeMessage(compact, layers, messageSizeInWords);
          // allocate symbol
          var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines
          var alignmentMap = new Int32Array(baseMatrixSize);
          var matrixSize;
          if (compact) {
              // no alignment marks in compact mode, alignmentMap is a no-op
              matrixSize = baseMatrixSize;
              for (var i /*int*/ = 0; i < alignmentMap.length; i++) {
                  alignmentMap[i] = i;
              }
          }
          else {
              matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);
              var origCenter = Integer.truncDivision(baseMatrixSize, 2);
              var center = Integer.truncDivision(matrixSize, 2);
              for (var i /*int*/ = 0; i < origCenter; i++) {
                  var newOffset = i + Integer.truncDivision(i, 15);
                  alignmentMap[origCenter - i - 1] = center - newOffset - 1;
                  alignmentMap[origCenter + i] = center + newOffset + 1;
              }
          }
          var matrix = new BitMatrix(matrixSize);
          // draw data bits
          for (var i /*int*/ = 0, rowOffset = 0; i < layers; i++) {
              var rowSize = (layers - i) * 4 + (compact ? 9 : 12);
              for (var j /*int*/ = 0; j < rowSize; j++) {
                  var columnOffset = j * 2;
                  for (var k /*int*/ = 0; k < 2; k++) {
                      if (messageBits.get(rowOffset + columnOffset + k)) {
                          matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);
                      }
                      if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {
                          matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);
                      }
                      if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {
                          matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);
                      }
                      if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {
                          matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);
                      }
                  }
              }
              rowOffset += rowSize * 8;
          }
          // draw mode message
          Encoder.drawModeMessage(matrix, compact, matrixSize, modeMessage);
          // draw alignment marks
          if (compact) {
              Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);
          }
          else {
              Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);
              for (var i /*int*/ = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {
                  for (var k /*int*/ = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {
                      matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);
                      matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);
                      matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);
                      matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);
                  }
              }
          }
          var aztec = new AztecCode();
          aztec.setCompact(compact);
          aztec.setSize(matrixSize);
          aztec.setLayers(layers);
          aztec.setCodeWords(messageSizeInWords);
          aztec.setMatrix(matrix);
          return aztec;
      };
      Encoder.drawBullsEye = function (matrix, center, size) {
          for (var i /*int*/ = 0; i < size; i += 2) {
              for (var j /*int*/ = center - i; j <= center + i; j++) {
                  matrix.set(j, center - i);
                  matrix.set(j, center + i);
                  matrix.set(center - i, j);
                  matrix.set(center + i, j);
              }
          }
          matrix.set(center - size, center - size);
          matrix.set(center - size + 1, center - size);
          matrix.set(center - size, center - size + 1);
          matrix.set(center + size, center - size);
          matrix.set(center + size, center - size + 1);
          matrix.set(center + size, center + size - 1);
      };
      Encoder.generateModeMessage = function (compact, layers, messageSizeInWords) {
          var modeMessage = new BitArray();
          if (compact) {
              modeMessage.appendBits(layers - 1, 2);
              modeMessage.appendBits(messageSizeInWords - 1, 6);
              modeMessage = Encoder.generateCheckWords(modeMessage, 28, 4);
          }
          else {
              modeMessage.appendBits(layers - 1, 5);
              modeMessage.appendBits(messageSizeInWords - 1, 11);
              modeMessage = Encoder.generateCheckWords(modeMessage, 40, 4);
          }
          return modeMessage;
      };
      Encoder.drawModeMessage = function (matrix, compact, matrixSize, modeMessage) {
          var center = Integer.truncDivision(matrixSize, 2);
          if (compact) {
              for (var i /*int*/ = 0; i < 7; i++) {
                  var offset = center - 3 + i;
                  if (modeMessage.get(i)) {
                      matrix.set(offset, center - 5);
                  }
                  if (modeMessage.get(i + 7)) {
                      matrix.set(center + 5, offset);
                  }
                  if (modeMessage.get(20 - i)) {
                      matrix.set(offset, center + 5);
                  }
                  if (modeMessage.get(27 - i)) {
                      matrix.set(center - 5, offset);
                  }
              }
          }
          else {
              for (var i /*int*/ = 0; i < 10; i++) {
                  var offset = center - 5 + i + Integer.truncDivision(i, 5);
                  if (modeMessage.get(i)) {
                      matrix.set(offset, center - 7);
                  }
                  if (modeMessage.get(i + 10)) {
                      matrix.set(center + 7, offset);
                  }
                  if (modeMessage.get(29 - i)) {
                      matrix.set(offset, center + 7);
                  }
                  if (modeMessage.get(39 - i)) {
                      matrix.set(center - 7, offset);
                  }
              }
          }
      };
      Encoder.generateCheckWords = function (bitArray, totalBits, wordSize) {
          var e_1, _a;
          // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed
          var messageSizeInWords = bitArray.getSize() / wordSize;
          var rs = new ReedSolomonEncoder(Encoder.getGF(wordSize));
          var totalWords = Integer.truncDivision(totalBits, wordSize);
          var messageWords = Encoder.bitsToWords(bitArray, wordSize, totalWords);
          rs.encode(messageWords, totalWords - messageSizeInWords);
          var startPad = totalBits % wordSize;
          var messageBits = new BitArray();
          messageBits.appendBits(0, startPad);
          try {
              for (var _b = __values$G(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var messageWord = _c.value /*: int*/;
                  messageBits.appendBits(messageWord, wordSize);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return messageBits;
      };
      Encoder.bitsToWords = function (stuffedBits, wordSize, totalWords) {
          var message = new Int32Array(totalWords);
          var i;
          var n;
          for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {
              var value = 0;
              for (var j /*int*/ = 0; j < wordSize; j++) {
                  value |= stuffedBits.get(i * wordSize + j) ? (1 << wordSize - j - 1) : 0;
              }
              message[i] = value;
          }
          return message;
      };
      Encoder.getGF = function (wordSize) {
          switch (wordSize) {
              case 4:
                  return GenericGF.AZTEC_PARAM;
              case 6:
                  return GenericGF.AZTEC_DATA_6;
              case 8:
                  return GenericGF.AZTEC_DATA_8;
              case 10:
                  return GenericGF.AZTEC_DATA_10;
              case 12:
                  return GenericGF.AZTEC_DATA_12;
              default:
                  throw new IllegalArgumentException('Unsupported word size ' + wordSize);
          }
      };
      Encoder.stuffBits = function (bits, wordSize) {
          var out = new BitArray();
          var n = bits.getSize();
          var mask = (1 << wordSize) - 2;
          for (var i /*int*/ = 0; i < n; i += wordSize) {
              var word = 0;
              for (var j /*int*/ = 0; j < wordSize; j++) {
                  if (i + j >= n || bits.get(i + j)) {
                      word |= 1 << (wordSize - 1 - j);
                  }
              }
              if ((word & mask) === mask) {
                  out.appendBits(word & mask, wordSize);
                  i--;
              }
              else if ((word & mask) === 0) {
                  out.appendBits(word | 1, wordSize);
                  i--;
              }
              else {
                  out.appendBits(word, wordSize);
              }
          }
          return out;
      };
      Encoder.totalBitsInLayer = function (layers, compact) {
          return ((compact ? 88 : 112) + 16 * layers) * layers;
      };
      Encoder.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words
      Encoder.DEFAULT_AZTEC_LAYERS = 0;
      Encoder.MAX_NB_BITS = 32;
      Encoder.MAX_NB_BITS_COMPACT = 4;
      Encoder.WORD_SIZE = Int32Array.from([
          4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
          12, 12, 12, 12, 12, 12, 12, 12, 12, 12
      ]);
      return Encoder;
  }());

  /*
  * Copyright 2013 ZXing authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  /**
   * Renders an Aztec code as a {@link BitMatrix}.
   */
  var AztecWriter = /** @class */ (function () {
      function AztecWriter() {
      }
      // @Override
      AztecWriter.prototype.encode = function (contents, format, width, height) {
          return this.encodeWithHints(contents, format, width, height, null);
      };
      // @Override
      AztecWriter.prototype.encodeWithHints = function (contents, format, width, height, hints) {
          var charset = StandardCharsets.ISO_8859_1;
          var eccPercent = Encoder$1.DEFAULT_EC_PERCENT;
          var layers = Encoder$1.DEFAULT_AZTEC_LAYERS;
          if (hints != null) {
              if (hints.has(EncodeHintType$1.CHARACTER_SET)) {
                  charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
              }
              if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {
                  eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
              }
              if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {
                  layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
              }
          }
          return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
      };
      AztecWriter.encodeLayers = function (contents, format, width, height, charset, eccPercent, layers) {
          if (format !== BarcodeFormat$1.AZTEC) {
              throw new IllegalArgumentException('Can only encode AZTEC, but got ' + format);
          }
          var aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);
          return AztecWriter.renderResult(aztec, width, height);
      };
      AztecWriter.renderResult = function (code, width, height) {
          var input = code.getMatrix();
          if (input == null) {
              throw new IllegalStateException();
          }
          var inputWidth = input.getWidth();
          var inputHeight = input.getHeight();
          var outputWidth = Math.max(width, inputWidth);
          var outputHeight = Math.max(height, inputHeight);
          var multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
          var leftPadding = (outputWidth - (inputWidth * multiple)) / 2;
          var topPadding = (outputHeight - (inputHeight * multiple)) / 2;
          var output = new BitMatrix(outputWidth, outputHeight);
          for (var inputY /*int*/ = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
              // Write the contents of this row of the barcode
              for (var inputX /*int*/ = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                  if (input.get(inputX, inputY)) {
                      output.setRegion(outputX, outputY, multiple, multiple);
                  }
              }
          }
          return output;
      };
      return AztecWriter;
  }());

  /**/
  class HTMLCanvasElementLuminanceSource$1 extends LuminanceSource {
      constructor(canvas) {
          super(canvas.width, canvas.height);
          this.canvas = canvas;
          this.buffer = HTMLCanvasElementLuminanceSource$1.makeBufferFromCanvasImageData(canvas);
      }
      static makeBufferFromCanvasImageData(canvas) {
          const canvasCtx = canvas.getContext('2d');
          if (!canvasCtx) {
              throw new Error('Couldn\'t get canvas context.');
          }
          const imageData = canvasCtx.getImageData(0, 0, canvas.width, canvas.height);
          return HTMLCanvasElementLuminanceSource$1.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
      }
      static toGrayscaleBuffer(imageBuffer, width, height) {
          const grayscaleBuffer = new Uint8ClampedArray(width * height);
          for (let i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++) {
              let gray;
              const alpha = imageBuffer[i + 3];
              // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent
              // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a
              // barcode image. Force any such pixel to be white:
              if (alpha === 0) {
                  gray = 0xFF;
              }
              else {
                  const pixelR = imageBuffer[i];
                  const pixelG = imageBuffer[i + 1];
                  const pixelB = imageBuffer[i + 2];
                  // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),
                  // (306*R) >> 10 is approximately equal to R*0.299, and so on.
                  // 0x200 >> 10 is 0.5, it implements rounding.
                  // tslint:disable-next-line:no-bitwise
                  gray = (306 * pixelR + 601 * pixelG + 117 * pixelB + 0x200) >> 10;
              }
              grayscaleBuffer[j] = gray;
          }
          return grayscaleBuffer;
      }
      getRow(y /*int*/, row) {
          if (y < 0 || y >= this.getHeight()) {
              throw new IllegalArgumentException('Requested row is outside the image: ' + y);
          }
          const width = this.getWidth();
          const start = y * width;
          if (row === null) {
              row = this.buffer.slice(start, start + width);
          }
          else {
              if (row.length < width) {
                  row = new Uint8ClampedArray(width);
              }
              // The underlying raster of image consists of bytes with the luminance values
              // TODO: can avoid set/slice?
              row.set(this.buffer.slice(start, start + width));
          }
          return row;
      }
      getMatrix() {
          return this.buffer;
      }
      isCropSupported() {
          return true;
      }
      crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
          super.crop(left, top, width, height);
          return this;
      }
      /**
       * This is always true, since the image is a gray-scale image.
       *
       * @return true
       */
      isRotateSupported() {
          return true;
      }
      rotateCounterClockwise() {
          this.rotate(-90);
          return this;
      }
      rotateCounterClockwise45() {
          this.rotate(-45);
          return this;
      }
      invert() {
          return new InvertedLuminanceSource(this);
      }
      getTempCanvasElement() {
          if (null === this.tempCanvasElement) {
              const tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');
              tempCanvasElement.width = this.canvas.width;
              tempCanvasElement.height = this.canvas.height;
              this.tempCanvasElement = tempCanvasElement;
          }
          return this.tempCanvasElement;
      }
      rotate(angle) {
          const tempCanvasElement = this.getTempCanvasElement();
          if (!tempCanvasElement) {
              throw new Error('Could not create a Canvas element.');
          }
          const angleRadians = angle * HTMLCanvasElementLuminanceSource$1.DEGREE_TO_RADIANS;
          // Calculate and set new dimensions for temp canvas
          const width = this.canvas.width;
          const height = this.canvas.height;
          const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
          const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
          tempCanvasElement.width = newWidth;
          tempCanvasElement.height = newHeight;
          const tempContext = tempCanvasElement.getContext('2d');
          if (!tempContext) {
              throw new Error('Could not create a Canvas Context element.');
          }
          // Draw at center of temp canvas to prevent clipping of image data
          tempContext.translate(newWidth / 2, newHeight / 2);
          tempContext.rotate(angleRadians);
          tempContext.drawImage(this.canvas, width / -2, height / -2);
          this.buffer = HTMLCanvasElementLuminanceSource$1.makeBufferFromCanvasImageData(tempCanvasElement);
          return this;
      }
  }
  HTMLCanvasElementLuminanceSource$1.DEGREE_TO_RADIANS = Math.PI / 180;

  /**
   * If navigator is present.
   */
  function hasNavigator() {
      return typeof navigator !== 'undefined';
  }
  /**
   * If mediaDevices under navigator is supported.
   */
  function isMediaDevicesSupported() {
      return hasNavigator() && !!navigator.mediaDevices;
  }
  /**
   * If enumerateDevices under navigator is supported.
   */
  function canEnumerateDevices() {
      return !!(isMediaDevicesSupported() && navigator.mediaDevices.enumerateDevices);
  }

  var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const defaultOptions = {
      delayBetweenScanAttempts: 500,
      delayBetweenScanSuccess: 500,
      tryPlayVideoTimeout: 5000,
  };
  /**
   * Base class for browser code reader.
   */
  class BrowserCodeReader$1 {
      /**
       * Creates an instance of BrowserCodeReader.
       * @param {Reader} reader The reader instance to decode the barcode
       * @param hints Holds the hints the user sets for the Reader.
       */
      constructor(reader, hints = new Map(), options = {}) {
          this.reader = reader;
          this.hints = hints;
          this.options = Object.assign(Object.assign({}, defaultOptions), options);
      }
      /**
       * Allows to change the possible formats the decoder should
       * search for while scanning some image. Useful for changing
       * the possible formats during BrowserCodeReader::scan.
       */
      set possibleFormats(formats) {
          this.hints.set(DecodeHintType$1.POSSIBLE_FORMATS, formats);
      }
      /**
       * Defines what the videoElement src will be.
       *
       * @param videoElement
       * @param stream The stream to be added as a source.
       */
      static addVideoSource(videoElement, stream) {
          // Older browsers may not have `srcObject`
          try {
              // @note Throws Exception if interrupted by a new loaded request
              videoElement.srcObject = stream;
          }
          catch (err) {
              // @note Avoid using this in new browsers, as it is going away.
              videoElement.src = URL.createObjectURL(stream);
          }
      }
      /**
       * Enables or disables the torch in a media stream.
       *
       * @experimental This doesn't work across all browsers and is still a Draft.
       */
      static mediaStreamSetTorch(track, onOff) {
          return __awaiter$1(this, void 0, void 0, function* () {
              yield track.applyConstraints({
                  advanced: [{
                          fillLightMode: onOff ? 'flash' : 'off',
                          torch: onOff ? true : false,
                      }],
              });
          });
      }
      /**
       * Checks if the stream has torch support.
       */
      static mediaStreamIsTorchCompatible(params) {
          const tracks = params.getVideoTracks();
          for (const track of tracks) {
              if (BrowserCodeReader$1.mediaStreamIsTorchCompatibleTrack(track)) {
                  return true;
              }
          }
          return false;
      }
      /**
       *
       * @param track The media stream track that will be checked for compatibility.
       */
      static mediaStreamIsTorchCompatibleTrack(track) {
          try {
              const capabilities = track.getCapabilities();
              return 'torch' in capabilities;
          }
          catch (err) {
              // some browsers may not be compatible with ImageCapture
              // so we are ignoring this for now.
              // tslint:disable-next-line:no-console
              console.error(err);
              // tslint:disable-next-line:no-console
              console.warn('Your browser may be not fully compatible with WebRTC and/or ImageCapture specs. Torch will not be available.');
              return false;
          }
      }
      /**
       * Checks if the given video element is currently playing.
       */
      static isVideoPlaying(video) {
          return video.currentTime > 0 && !video.paused && video.readyState > 2;
      }
      /**
       * Searches and validates a media element.
       */
      static getMediaElement(mediaElementId, type) {
          const mediaElement = document.getElementById(mediaElementId);
          if (!mediaElement) {
              throw new ArgumentException(`element with id '${mediaElementId}' not found`);
          }
          if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
              throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);
          }
          return mediaElement;
      }
      /**
       * Receives a source and makes sure to return a Video Element from it or fail.
       */
      static createVideoElement(videoThingy) {
          if (videoThingy instanceof HTMLVideoElement) {
              return videoThingy;
          }
          if (typeof videoThingy === 'string') {
              return BrowserCodeReader$1.getMediaElement(videoThingy, 'video');
          }
          if (!videoThingy && typeof document !== 'undefined') {
              const videoElement = document.createElement('video');
              videoElement.width = 200;
              videoElement.height = 200;
              return videoElement;
          }
          throw new Error('Couldn\'t get videoElement from videoSource!');
      }
      /**
       * Receives a source and makes sure to return an Image Element from it or fail.
       */
      static prepareImageElement(imageSource) {
          if (imageSource instanceof HTMLImageElement) {
              return imageSource;
          }
          if (typeof imageSource === 'string') {
              return BrowserCodeReader$1.getMediaElement(imageSource, 'img');
          }
          if (typeof imageSource === 'undefined') {
              const imageElement = document.createElement('img');
              imageElement.width = 200;
              imageElement.height = 200;
              return imageElement;
          }
          throw new Error('Couldn\'t get imageElement from imageSource!');
      }
      /**
       * Sets a HTMLVideoElement for scanning or creates a new one.
       *
       * @param videoElem The HTMLVideoElement to be set.
       */
      static prepareVideoElement(videoElem) {
          const videoElement = BrowserCodeReader$1.createVideoElement(videoElem);
          // @todo the following lines should not always be done this way, should conditionally
          // change according were we created the element or not
          // Needed for iOS 11
          videoElement.setAttribute('autoplay', 'true');
          videoElement.setAttribute('muted', 'true');
          videoElement.setAttribute('playsinline', 'true');
          return videoElement;
      }
      /**
       * Checks if and HTML image is loaded.
       */
      static isImageLoaded(img) {
          // During the onload event, IE correctly identifies any images that
          // weren't downloaded as not complete. Others should too. Gecko-based
          // browsers act like NS4 in that they report this incorrectly.
          if (!img.complete) {
              return false;
          }
          // However, they do have two very useful properties: naturalWidth and
          // naturalHeight. These give the true size of the image. If it failed
          // to load, either of these should be zero.
          if (img.naturalWidth === 0) {
              return false;
          }
          // No other way of checking: assume it’s ok.
          return true;
      }
      /**
       * Creates a binaryBitmap based in a canvas.
       *
       * @param canvas HTML canvas element containing the image source draw.
       */
      static createBinaryBitmapFromCanvas(canvas) {
          const luminanceSource = new HTMLCanvasElementLuminanceSource$1(canvas);
          const hybridBinarizer = new HybridBinarizer(luminanceSource);
          return new BinaryBitmap(hybridBinarizer);
      }
      /**
       * Overwriting this allows you to manipulate the snapshot image in anyway you want before decode.
       */
      static drawImageOnCanvas(canvasElementContext, srcElement) {
          canvasElementContext.drawImage(srcElement, 0, 0);
      }
      static getMediaElementDimensions(mediaElement) {
          if (mediaElement instanceof HTMLVideoElement) {
              return {
                  height: mediaElement.videoHeight,
                  width: mediaElement.videoWidth,
              };
          }
          if (mediaElement instanceof HTMLImageElement) {
              return {
                  height: mediaElement.naturalHeight || mediaElement.height,
                  width: mediaElement.naturalWidth || mediaElement.width,
              };
          }
          throw new Error('Couldn\'t find the Source\'s dimensions!');
      }
      /**
       * 🖌 Prepares the canvas for capture and scan frames.
       */
      static createCaptureCanvas(mediaElement) {
          if (!mediaElement) {
              throw new ArgumentException('Cannot create a capture canvas without a media element.');
          }
          if (typeof document === 'undefined') {
              throw new Error('The page "Document" is undefined, make sure you\'re running in a browser.');
          }
          const canvasElement = document.createElement('canvas');
          const { width, height } = BrowserCodeReader$1.getMediaElementDimensions(mediaElement);
          canvasElement.style.width = width + 'px';
          canvasElement.style.height = height + 'px';
          canvasElement.width = width;
          canvasElement.height = height;
          return canvasElement;
      }
      /**
       * Just tries to play the video and logs any errors.
       * The play call is only made is the video is not already playing.
       */
      static tryPlayVideo(videoElement) {
          return __awaiter$1(this, void 0, void 0, function* () {
              if (videoElement === null || videoElement === void 0 ? void 0 : videoElement.ended) {
                  // tslint:disable-next-line:no-console
                  console.error('Trying to play video that has ended.');
                  return false;
              }
              if (BrowserCodeReader$1.isVideoPlaying(videoElement)) {
                  // tslint:disable-next-line:no-console
                  console.warn('Trying to play video that is already playing.');
                  return true;
              }
              try {
                  yield videoElement.play();
                  return true;
              }
              catch (error) {
                  // tslint:disable-next-line:no-console
                  console.warn('It was not possible to play the video.', error);
                  return false;
              }
          });
      }
      /**
       * Creates a canvas and draws the current image frame from the media element on it.
       *
       * @param mediaElement HTML media element to extract an image frame from.
       */
      static createCanvasFromMediaElement(mediaElement) {
          const canvas = BrowserCodeReader$1.createCaptureCanvas(mediaElement);
          const ctx = canvas.getContext('2d');
          if (!ctx) {
              throw new Error('Couldn\'t find Canvas 2D Context.');
          }
          BrowserCodeReader$1.drawImageOnCanvas(ctx, mediaElement);
          return canvas;
      }
      /**
       * Creates a binaryBitmap based in some image source.
       *
       * @param mediaElement HTML element containing drawable image source.
       */
      static createBinaryBitmapFromMediaElem(mediaElement) {
          const canvas = BrowserCodeReader$1.createCanvasFromMediaElement(mediaElement);
          return BrowserCodeReader$1.createBinaryBitmapFromCanvas(canvas);
      }
      static destroyImageElement(imageElement) {
          imageElement.src = '';
          imageElement.removeAttribute('src');
          imageElement = undefined;
      }
      /**
       * Lists all the available video input devices.
       */
      static listVideoInputDevices() {
          return __awaiter$1(this, void 0, void 0, function* () {
              if (!hasNavigator()) {
                  throw new Error('Can\'t enumerate devices, navigator is not present.');
              }
              if (!canEnumerateDevices()) {
                  throw new Error('Can\'t enumerate devices, method not supported.');
              }
              const devices = yield navigator.mediaDevices.enumerateDevices();
              const videoDevices = [];
              for (const device of devices) {
                  const kind = device.kind === 'video' ? 'videoinput' : device.kind;
                  if (kind !== 'videoinput') {
                      continue;
                  }
                  const deviceId = device.deviceId || device.id;
                  const label = device.label || `Video device ${videoDevices.length + 1}`;
                  const groupId = device.groupId;
                  const videoDevice = { deviceId, label, kind, groupId };
                  videoDevices.push(videoDevice);
              }
              return videoDevices;
          });
      }
      /**
       * Let's you find a device using it's Id.
       */
      static findDeviceById(deviceId) {
          return __awaiter$1(this, void 0, void 0, function* () {
              const devices = yield BrowserCodeReader$1.listVideoInputDevices();
              if (!devices) {
                  return;
              }
              return devices.find((x) => x.deviceId === deviceId);
          });
      }
      /**
       * Unbinds a HTML video src property.
       */
      static cleanVideoSource(videoElement) {
          if (!videoElement) {
              return;
          }
          // forgets about that element 😢
          try {
              videoElement.srcObject = null;
          }
          catch (err) {
              videoElement.src = '';
          }
          if (videoElement) {
              videoElement.removeAttribute('src');
          }
      }
      /**
       * Stops all media streams that are created.
       */
      static releaseAllStreams() {
          if (BrowserCodeReader$1.streamTracker.length !== 0) {
              // tslint:disable-next-line:no-console
              BrowserCodeReader$1.streamTracker.forEach((mediaStream) => {
                  mediaStream.getTracks().forEach((track) => track.stop());
              });
          }
          BrowserCodeReader$1.streamTracker = [];
      }
      /**
       * Waits for a video to load and then hits play on it.
       * To accomplish that, it binds listeners and callbacks to the video element.
       *
       * @param element The video element.
       * @param callbackFn Callback invoked when the video is played.
       */
      static playVideoOnLoadAsync(element, timeout) {
          return __awaiter$1(this, void 0, void 0, function* () {
              // if canplay was already fired, we won't know when to play, so just give it a try
              const isPlaying = yield BrowserCodeReader$1.tryPlayVideo(element);
              if (isPlaying) {
                  return true;
              }
              return new Promise((resolve, reject) => {
                  // waits 3 seconds or rejects.
                  const timeoutId = setTimeout(() => {
                      if (BrowserCodeReader$1.isVideoPlaying(element)) {
                          // if video is playing then we had success, just ignore
                          return;
                      }
                      reject(false);
                      element.removeEventListener('canplay', videoCanPlayListener);
                  }, timeout);
                  /**
                   * Should contain the current registered listener for video loaded-metadata,
                   * used to unregister that listener when needed.
                   */
                  const videoCanPlayListener = () => {
                      BrowserCodeReader$1.tryPlayVideo(element).then((hasPlayed) => {
                          clearTimeout(timeoutId);
                          element.removeEventListener('canplay', videoCanPlayListener);
                          resolve(hasPlayed);
                      });
                  };
                  // both should be unregistered after called
                  element.addEventListener('canplay', videoCanPlayListener);
              });
          });
      }
      /**
       * Sets the new stream and request a new decoding-with-delay.
       *
       * @param stream The stream to be shown in the video element.
       * @param decodeFn A callback for the decode method.
       */
      static attachStreamToVideo(stream, preview, previewPlayTimeout = 5000) {
          return __awaiter$1(this, void 0, void 0, function* () {
              const videoElement = BrowserCodeReader$1.prepareVideoElement(preview);
              BrowserCodeReader$1.addVideoSource(videoElement, stream);
              yield BrowserCodeReader$1.playVideoOnLoadAsync(videoElement, previewPlayTimeout);
              return videoElement;
          });
      }
      /**
       * Returns a Promise that resolves when the given image element loads.
       */
      static _waitImageLoad(element) {
          return new Promise((resolve, reject) => {
              const timeout = 10000;
              // waits 10 seconds or rejects.
              const timeoutId = setTimeout(() => {
                  if (BrowserCodeReader$1.isImageLoaded(element)) {
                      // if video is playing then we had success, just ignore
                      return;
                  }
                  // removes the listener
                  element.removeEventListener('load', imageLoadedListener);
                  // rejects the load
                  reject();
              }, timeout);
              const imageLoadedListener = () => {
                  clearTimeout(timeoutId);
                  // removes the listener
                  element.removeEventListener('load', imageLoadedListener);
                  // resolves the load
                  resolve();
              };
              element.addEventListener('load', imageLoadedListener);
          });
      }
      /**
       * Checks if the `callbackFn` is defined, otherwise throws.
       */
      static checkCallbackFnOrThrow(callbackFn) {
          if (!callbackFn) {
              throw new ArgumentException('`callbackFn` is a required parameter, you cannot capture results without it.');
          }
      }
      /**
       * Standard method to dispose a media stream object.
       */
      static disposeMediaStream(stream) {
          stream.getVideoTracks().forEach((x) => x.stop());
          stream = undefined;
      }
      /**
       * Gets the BinaryBitmap for ya! (and decodes it)
       */
      decode(element) {
          // get binary bitmap for decode function
          const canvas = BrowserCodeReader$1.createCanvasFromMediaElement(element);
          return this.decodeFromCanvas(canvas);
      }
      /**
       * Call the encapsulated readers decode
       */
      decodeBitmap(binaryBitmap) {
          return this.reader.decode(binaryBitmap, this.hints);
      }
      /**
       * Decodes some barcode from a canvas!
       */
      decodeFromCanvas(canvas) {
          const binaryBitmap = BrowserCodeReader$1.createBinaryBitmapFromCanvas(canvas);
          return this.decodeBitmap(binaryBitmap);
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromImageElement(source) {
          return __awaiter$1(this, void 0, void 0, function* () {
              if (!source) {
                  throw new ArgumentException('An image element must be provided.');
              }
              const element = BrowserCodeReader$1.prepareImageElement(source);
              // onLoad will remove it's callback once done
              // we do not need to dispose or destroy the image
              // since it came from the user
              return yield this._decodeOnLoadImage(element);
          });
      }
      /**
       * Decodes an image from a URL.
       */
      decodeFromImageUrl(url) {
          return __awaiter$1(this, void 0, void 0, function* () {
              if (!url) {
                  throw new ArgumentException('An URL must be provided.');
              }
              const element = BrowserCodeReader$1.prepareImageElement();
              // loads the image.
              element.src = url;
              try {
                  // it waits the task so we can destroy the created image after
                  return yield this.decodeFromImageElement(element);
              }
              finally {
                  // we created this element, so we destroy it
                  BrowserCodeReader$1.destroyImageElement(element);
              }
          });
      }
      /**
       * Continuously tries to decode the barcode from a stream obtained from the given constraints
       * while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [previewElem] the video element in page where to show the video while
       *  decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in
       *  which case no video will be shown.
       */
      decodeFromConstraints(constraints, previewElem, callbackFn) {
          return __awaiter$1(this, void 0, void 0, function* () {
              BrowserCodeReader$1.checkCallbackFnOrThrow(callbackFn);
              const stream = yield this.getUserMedia(constraints);
              try {
                  return yield this.decodeFromStream(stream, previewElem, callbackFn);
              }
              catch (error) {
                  BrowserCodeReader$1.disposeMediaStream(stream);
                  throw error;
              }
          });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given constraints
       * while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [preview] the video element in page where to show the video
       *  while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined,
       *  in which case no video will be shown.
       */
      decodeFromStream(stream, preview, callbackFn) {
          return __awaiter$1(this, void 0, void 0, function* () {
              BrowserCodeReader$1.checkCallbackFnOrThrow(callbackFn);
              const timeout = this.options.tryPlayVideoTimeout;
              const video = yield BrowserCodeReader$1.attachStreamToVideo(stream, preview, timeout);
              // IF we receive a stream from the user, it's not our job to dispose it
              const finalizeCallback = () => {
                  // stops video tracks and releases the stream reference
                  BrowserCodeReader$1.disposeMediaStream(stream);
                  // this video was just a preview, so in order
                  // to release the stream we gotta stop showing
                  // it (the stream) in the video element
                  BrowserCodeReader$1.cleanVideoSource(video);
              };
              const originalControls = this.scan(video, callbackFn, finalizeCallback);
              const videoTracks = stream.getVideoTracks();
              const controls = Object.assign(Object.assign({}, originalControls), { stop() {
                      originalControls.stop();
                  }, streamVideoConstraintsApply(constraints, trackFilter) {
                      return __awaiter$1(this, void 0, void 0, function* () {
                          const tracks = trackFilter ? videoTracks.filter(trackFilter) : videoTracks;
                          for (const track of tracks) {
                              yield track.applyConstraints(constraints);
                          }
                      });
                  },
                  streamVideoConstraintsGet(trackFilter) {
                      return videoTracks.find(trackFilter).getConstraints();
                  },
                  streamVideoSettingsGet(trackFilter) {
                      return videoTracks.find(trackFilter).getSettings();
                  },
                  streamVideoCapabilitiesGet(trackFilter) {
                      return videoTracks.find(trackFilter).getCapabilities();
                  } });
              const isTorchAvailable = BrowserCodeReader$1.mediaStreamIsTorchCompatible(stream);
              if (isTorchAvailable) {
                  const torchTrack = videoTracks === null || videoTracks === void 0 ? void 0 : videoTracks.find((t) => BrowserCodeReader$1.mediaStreamIsTorchCompatibleTrack(t));
                  const switchTorch = (onOff) => __awaiter$1(this, void 0, void 0, function* () {
                      yield BrowserCodeReader$1.mediaStreamSetTorch(torchTrack, onOff);
                  });
                  controls.switchTorch = switchTorch;
                  const stop = () => {
                      originalControls.stop();
                      switchTorch(false);
                  };
                  controls.stop = stop;
              }
              return controls;
          });
      }
      /**
       * Continuously tries to decode the barcode from the device specified by device while showing
       * the video in the specified video element.
       *
       * @param {string|null} [deviceId] the id of one of the devices obtained after calling
       *  getVideoInputDevices. Can be undefined, in this case it will decode from one of the
       *  available devices, preferring the main camera (environment facing) if available.
       * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video
       *  while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined,
       *  in which case no video will be shown.
       */
      decodeFromVideoDevice(deviceId, previewElem, callbackFn) {
          return __awaiter$1(this, void 0, void 0, function* () {
              BrowserCodeReader$1.checkCallbackFnOrThrow(callbackFn);
              let videoConstraints;
              if (!deviceId) {
                  videoConstraints = { facingMode: 'environment' };
              }
              else {
                  videoConstraints = { deviceId: { exact: deviceId } };
              }
              const constraints = { video: videoConstraints };
              return yield this.decodeFromConstraints(constraints, previewElem, callbackFn);
          });
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromVideoElement(source, callbackFn) {
          return __awaiter$1(this, void 0, void 0, function* () {
              BrowserCodeReader$1.checkCallbackFnOrThrow(callbackFn);
              if (!source) {
                  throw new ArgumentException('A video element must be provided.');
              }
              // we do not create a video element
              const element = BrowserCodeReader$1.prepareVideoElement(source);
              const timeout = this.options.tryPlayVideoTimeout;
              // plays the video
              yield BrowserCodeReader$1.playVideoOnLoadAsync(element, timeout);
              // starts decoding after played the video
              return this.scan(element, callbackFn);
          });
      }
      /**
       * Decodes a video from a URL until it ends.
       */
      decodeFromVideoUrl(url, callbackFn) {
          return __awaiter$1(this, void 0, void 0, function* () {
              BrowserCodeReader$1.checkCallbackFnOrThrow(callbackFn);
              if (!url) {
                  throw new ArgumentException('An URL must be provided.');
              }
              // creates a new element
              const element = BrowserCodeReader$1.prepareVideoElement();
              // starts loading the video
              element.src = url;
              const finalizeCallback = () => {
                  // dispose created video element
                  BrowserCodeReader$1.cleanVideoSource(element);
              };
              const timeout = this.options.tryPlayVideoTimeout;
              // plays the video
              yield BrowserCodeReader$1.playVideoOnLoadAsync(element, timeout);
              // starts decoding after played the video
              const controls = this.scan(element, callbackFn, finalizeCallback);
              return controls;
          });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given
       * constraints while showing the video in the specified video element.
       *
       * @param constraints the media stream constraints to get s valid media stream to decode from
       * @param videoSource the video element in page where to show the video while decoding.
       *  Can be either an element id or directly an HTMLVideoElement. Can be undefined,
       *  in which case no video will be shown.
       *  The decoding result.
       */
      decodeOnceFromConstraints(constraints, videoSource) {
          return __awaiter$1(this, void 0, void 0, function* () {
              const stream = yield this.getUserMedia(constraints);
              return yield this.decodeOnceFromStream(stream, videoSource);
          });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given
       * constraints while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding.
       *  Can be either an element id or directly an HTMLVideoElement. Can be undefined,
       *  in which case no video will be shown.
       */
      decodeOnceFromStream(stream, preview) {
          return __awaiter$1(this, void 0, void 0, function* () {
              const receivedPreview = Boolean(preview);
              const video = yield BrowserCodeReader$1.attachStreamToVideo(stream, preview);
              try {
                  const result = yield this.scanOneResult(video);
                  return result;
              }
              finally {
                  if (!receivedPreview) {
                      BrowserCodeReader$1.cleanVideoSource(video);
                  }
              }
          });
      }
      /**
       * In one attempt, tries to decode the barcode from the device specified by deviceId
       * while showing the video in the specified video element.
       *
       * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices.
       *  Can be undefined, in this case it will decode from one of the available devices,
       *  preferring the main camera (environment facing) if available.
       * @param videoSource the video element in page where to show the video while decoding.
       *  Can be either an element id or directly an HTMLVideoElement. Can be undefined,
       *  in which case no video will be shown.
       */
      decodeOnceFromVideoDevice(deviceId, videoSource) {
          return __awaiter$1(this, void 0, void 0, function* () {
              let videoConstraints;
              if (!deviceId) {
                  videoConstraints = { facingMode: 'environment' };
              }
              else {
                  videoConstraints = { deviceId: { exact: deviceId } };
              }
              const constraints = { video: videoConstraints };
              return yield this.decodeOnceFromConstraints(constraints, videoSource);
          });
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeOnceFromVideoElement(source) {
          return __awaiter$1(this, void 0, void 0, function* () {
              if (!source) {
                  throw new ArgumentException('A video element must be provided.');
              }
              // we do not create a video element
              const element = BrowserCodeReader$1.prepareVideoElement(source);
              const timeout = this.options.tryPlayVideoTimeout;
              // plays the video
              yield BrowserCodeReader$1.playVideoOnLoadAsync(element, timeout);
              // starts decoding after played the video
              return yield this.scanOneResult(element);
          });
      }
      /**
       * Decodes a video from a URL.
       */
      decodeOnceFromVideoUrl(url) {
          return __awaiter$1(this, void 0, void 0, function* () {
              if (!url) {
                  throw new ArgumentException('An URL must be provided.');
              }
              // creates a new element
              const element = BrowserCodeReader$1.prepareVideoElement();
              // starts loading the video
              element.src = url;
              const task = this.decodeOnceFromVideoElement(element);
              try {
                  // it waits the task so we can destroy the created image after
                  return yield task;
              }
              finally {
                  // we created this element, so we destroy it
                  BrowserCodeReader$1.cleanVideoSource(element);
              }
          });
      }
      /**
       * Tries to decode from the video input until it finds some value.
       */
      scanOneResult(element, retryIfNotFound = true, retryIfChecksumError = true, retryIfFormatError = true) {
          return new Promise((resolve, reject) => {
              // reuses the scan API, but returns at the first successful result
              this.scan(element, (result, error, controls) => {
                  if (result) {
                      // good result, returning
                      resolve(result);
                      controls.stop();
                      return;
                  }
                  if (error) {
                      // checks if it should retry
                      if (error instanceof NotFoundException && retryIfNotFound) {
                          return;
                      }
                      if (error instanceof ChecksumException && retryIfChecksumError) {
                          return;
                      }
                      if (error instanceof FormatException && retryIfFormatError) {
                          return;
                      }
                      // not re-trying
                      controls.stop(); // stops scan loop
                      reject(error); // returns the error
                  }
              });
          });
      }
      /**
       * Continuously decodes from video input.
       *
       * @param element HTML element to scan/decode from. It will not be disposed or destroyed.
       * @param callbackFn Called after every scan attempt, being it successful or errored.
       * @param finalizeCallback Called after scan process reaches the end or stop is called.
       */
      scan(element, callbackFn, finalizeCallback) {
          BrowserCodeReader$1.checkCallbackFnOrThrow(callbackFn);
          /**
           * The HTML canvas element, used to draw the video or image's frame for decoding.
           */
          let captureCanvas = BrowserCodeReader$1.createCaptureCanvas(element);
          /**
           * The HTML canvas element context.
           */
          let captureCanvasContext = captureCanvas.getContext('2d');
          // cannot proceed w/o this
          if (!captureCanvasContext) {
              throw new Error('Couldn\'t create canvas for visual element scan.');
          }
          const disposeCanvas = () => {
              captureCanvasContext = undefined;
              captureCanvas = undefined;
          };
          let stopScan = false;
          let lastTimeoutId;
          // can be called to break the scan loop
          const stop = () => {
              stopScan = true;
              clearTimeout(lastTimeoutId);
              disposeCanvas();
              if (finalizeCallback) {
                  finalizeCallback();
              }
          };
          // created for extensibility
          const controls = { stop };
          // this async loop allows infinite (or almost? maybe) scans
          const loop = () => {
              if (stopScan) {
                  // no need to clear timeouts as none was create yet in this scope.
                  return;
              }
              try {
                  BrowserCodeReader$1.drawImageOnCanvas(captureCanvasContext, element);
                  const result = this.decodeFromCanvas(captureCanvas);
                  callbackFn(result, undefined, controls);
                  lastTimeoutId = setTimeout(loop, this.options.delayBetweenScanSuccess);
              }
              catch (error) {
                  callbackFn(undefined, error, controls);
                  const isChecksumError = error instanceof ChecksumException;
                  const isFormatError = error instanceof FormatException;
                  const isNotFound = error instanceof NotFoundException;
                  if (isChecksumError || isFormatError || isNotFound) {
                      // trying again
                      lastTimeoutId = setTimeout(loop, this.options.delayBetweenScanAttempts);
                      return;
                  }
                  // not trying again
                  disposeCanvas();
                  if (finalizeCallback) {
                      finalizeCallback(error);
                  }
              }
          };
          // starts the async loop
          loop();
          return controls;
      }
      /**
       * Waits for the image to load and then tries to decode it.
       */
      _decodeOnLoadImage(element) {
          return __awaiter$1(this, void 0, void 0, function* () {
              const isImageLoaded = BrowserCodeReader$1.isImageLoaded(element);
              if (!isImageLoaded) {
                  yield BrowserCodeReader$1._waitImageLoad(element);
              }
              return this.decode(element);
          });
      }
      /**
       * Get MediaStream from browser to be used.
       * @param constraints constraints the media stream constraints to get s valid media stream to decode from.
       * @private For private use.
       */
      getUserMedia(constraints) {
          return __awaiter$1(this, void 0, void 0, function* () {
              const stream = yield navigator.mediaDevices.getUserMedia(constraints);
              BrowserCodeReader$1.streamTracker.push(stream);
              return stream;
          });
      }
  }
  /**
   * Keeps track to created media streams.
   * @private there is no need this array to be accessible from outside.
   */
  BrowserCodeReader$1.streamTracker = [];

  /**
   * Aztec Code reader to use from browser.
   *
   * @class BrowserAztecCodeReader
   * @extends {BrowserCodeReader}
   */
  class BrowserAztecCodeReader$1 extends BrowserCodeReader$1 {
      /**
       * Creates an instance of BrowserAztecCodeReader.
       */
      constructor(hints, options) {
          super(new AztecReader(), hints, options);
      }
  }

  /**
   * Reader to be used for any One Dimension type barcode.
   */
  class BrowserMultiFormatOneDReader extends BrowserCodeReader$1 {
      /**
       * Creates an instance of BrowserBarcodeReader.
       * @param {Map<DecodeHintType, any>} hints?
       * @param options
       */
      constructor(hints, options) {
          super(new MultiFormatOneDReader(hints), hints, options);
      }
  }

  /**
   * QR Code reader to use from browser.
   */
  class BrowserDatamatrixCodeReader$1 extends BrowserCodeReader$1 {
      /**
       * Creates an instance of BrowserQRCodeReader.
       */
      constructor(hints, options) {
          super(new DataMatrixReader(), hints, options);
      }
  }

  class BrowserMultiFormatReader$1 extends BrowserCodeReader$1 {
      constructor(hints, options) {
          const reader = new MultiFormatReader();
          reader.setHints(hints);
          super(reader, hints, options);
          this.reader = reader;
      }
      set possibleFormats(formats) {
          this.hints.set(DecodeHintType$1.POSSIBLE_FORMATS, formats);
          this.reader.setHints(this.hints);
      }
      /**
       * Overwrite decodeBitmap to call decodeWithState, which will pay
       * attention to the hints set in the constructor function
       */
      decodeBitmap(binaryBitmap) {
          return this.reader.decodeWithState(binaryBitmap);
      }
      /**
       * Allows to change hints in runtime.
       */
      setHints(hints) {
          this.hints = hints;
          this.reader.setHints(this.hints);
      }
  }

  /**
   * QR Code reader to use from browser.
   */
  class BrowserPDF417Reader$1 extends BrowserCodeReader$1 {
      /**
       * Creates an instance of BrowserPDF417Reader.
       */
      constructor(hints, options) {
          super(new PDF417Reader(), hints, options);
      }
  }

  /**
   * QR Code reader to use from browser.
   */
  class BrowserQRCodeReader$1 extends BrowserCodeReader$1 {
      /**
       * Creates an instance of BrowserQRCodeReader.
       */
      constructor(hints, options) {
          super(new QRCodeReader(), hints, options);
      }
  }

  const svgNs = 'http://www.w3.org/2000/svg';
  /**/
  class BrowserCodeSvgWriter {
      /**
       * Constructs. 😉
       */
      constructor(containerElement) {
          if (typeof containerElement === 'string') {
              const container = document.getElementById(containerElement);
              if (!container) {
                  throw new Error(`Could not find a Container element with '${containerElement}'.`);
              }
              this.containerElement = container;
          }
          else {
              this.containerElement = containerElement;
          }
      }
      /**
       * Writes the QR code to a SVG and renders it in the container.
       */
      write(contents, width, height, hints) {
          if (contents.length === 0) {
              throw new IllegalArgumentException('Found empty contents');
          }
          if (width < 0 || height < 0) {
              throw new IllegalArgumentException('Requested dimensions are too small: ' + width + 'x' + height);
          }
          const quietZone = hints && hints.get(EncodeHintType$1.MARGIN) !== undefined
              ? Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10)
              : BrowserCodeSvgWriter.QUIET_ZONE_SIZE;
          const code = this.encode(hints, contents);
          return this.renderResult(code, width, height, quietZone);
      }
      /**
       * Creates a SVG element.
       */
      createSVGElement(w, h) {
          const el = document.createElementNS(BrowserCodeSvgWriter.SVG_NS, 'svg');
          el.setAttributeNS(svgNs, 'width', h.toString());
          el.setAttributeNS(svgNs, 'height', w.toString());
          return el;
      }
      /**
       * Creates a SVG rect.
       */
      createSvgPathPlaceholderElement(w, h) {
          const el = document.createElementNS(BrowserCodeSvgWriter.SVG_NS, 'path');
          el.setAttributeNS(svgNs, 'd', `M0 0h${w}v${h}H0z`);
          el.setAttributeNS(svgNs, 'fill', 'none');
          return el;
      }
      /**
       * Creates a SVG rect.
       */
      createSvgRectElement(x, y, w, h) {
          const el = document.createElementNS(BrowserCodeSvgWriter.SVG_NS, 'rect');
          el.setAttributeNS(svgNs, 'x', x.toString());
          el.setAttributeNS(svgNs, 'y', y.toString());
          el.setAttributeNS(svgNs, 'height', w.toString());
          el.setAttributeNS(svgNs, 'width', h.toString());
          el.setAttributeNS(svgNs, 'fill', '#000000');
          return el;
      }
      /**
       * Encodes the content to a Barcode type.
       */
      encode(hints, contents) {
          let errorCorrectionLevel = ErrorCorrectionLevel.L;
          if (hints && hints.get(EncodeHintType$1.ERROR_CORRECTION) !== undefined) {
              const correctionStr = hints.get(EncodeHintType$1.ERROR_CORRECTION).toString();
              errorCorrectionLevel = ErrorCorrectionLevel.fromString(correctionStr);
          }
          const code = Encoder.encode(contents, errorCorrectionLevel, hints);
          return code;
      }
      /**
       * Renders the SVG in the container.
       *
       * @note the input matrix uses 0 == white, 1 == black. The output matrix
       *  uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
       */
      renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {
          // if (this.format && format != this.format) {
          //   throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format)
          // }
          const input = code.getMatrix();
          if (input === null) {
              throw new IllegalStateException();
          }
          const inputWidth = input.getWidth();
          const inputHeight = input.getHeight();
          const qrWidth = inputWidth + (quietZone * 2);
          const qrHeight = inputHeight + (quietZone * 2);
          const outputWidth = Math.max(width, qrWidth);
          const outputHeight = Math.max(height, qrHeight);
          const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
          // Padding includes both the quiet zone and the extra white pixels to accommodate the requested
          // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.
          // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will
          // handle all the padding from 100x100 (the actual QR) up to 200x160.
          const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);
          const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);
          const svgElement = this.createSVGElement(outputWidth, outputHeight);
          const placeholder = this.createSvgPathPlaceholderElement(width, height);
          svgElement.appendChild(placeholder);
          this.containerElement.appendChild(svgElement);
          // 2D loop
          for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
              // Write the contents of this row of the barcode
              for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                  if (input.get(inputX, inputY) === 1) {
                      const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
                      svgElement.appendChild(svgRectElement);
                  }
              }
          }
          return svgElement;
      }
  }
  /**
   * Default quiet zone in pixels.
   */
  BrowserCodeSvgWriter.QUIET_ZONE_SIZE = 4;
  /**
   * SVG markup NameSpace
   */
  BrowserCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';

  const svgNs$1 = 'http://www.w3.org/2000/svg';
  /**/
  class BrowserQRCodeSvgWriter {
      /**
       * Writes and renders a QRCode SVG element.
       *
       * @param contents
       * @param width
       * @param height
       * @param hints
       */
      write(contents, width, height, hints) {
          if (contents.length === 0) {
              throw new IllegalArgumentException('Found empty contents');
          }
          // if (format != BarcodeFormat.QR_CODE) {
          //   throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format)
          // }
          if (width < 0 || height < 0) {
              throw new IllegalArgumentException('Requested dimensions are too small: ' + width + 'x' + height);
          }
          let errorCorrectionLevel = ErrorCorrectionLevel.L;
          let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
          if (hints) {
              if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
                  const correctionStr = hints.get(EncodeHintType$1.ERROR_CORRECTION).toString();
                  errorCorrectionLevel = ErrorCorrectionLevel.fromString(correctionStr);
              }
              if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {
                  quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
              }
          }
          const code = Encoder.encode(contents, errorCorrectionLevel, hints);
          return this.renderResult(code, width, height, quietZone);
      }
      /**
       * Renders the result and then appends it to the DOM.
       */
      writeToDom(containerElement, contents, width, height, hints) {
          if (typeof containerElement === 'string') {
              const targetEl = document.querySelector(containerElement);
              if (!targetEl) {
                  throw new Error('Could no find the target HTML element.');
              }
              containerElement = targetEl;
          }
          const svgElement = this.write(contents, width, height, hints);
          if (containerElement instanceof HTMLElement) {
              containerElement.appendChild(svgElement);
          }
      }
      /**
       * Note that the input matrix uses 0 == white, 1 == black.
       * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
       */
      renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {
          const input = code.getMatrix();
          if (input === null) {
              throw new IllegalStateException();
          }
          const inputWidth = input.getWidth();
          const inputHeight = input.getHeight();
          const qrWidth = inputWidth + (quietZone * 2);
          const qrHeight = inputHeight + (quietZone * 2);
          const outputWidth = Math.max(width, qrWidth);
          const outputHeight = Math.max(height, qrHeight);
          const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
          // Padding includes both the quiet zone and the extra white pixels to accommodate the requested
          // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.
          // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will
          // handle all the padding from 100x100 (the actual QR) up to 200x160.
          const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);
          const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);
          const svgElement = this.createSVGElement(outputWidth, outputHeight);
          for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
              // Write the contents of this row of the barcode
              for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                  if (input.get(inputX, inputY) === 1) {
                      const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
                      svgElement.appendChild(svgRectElement);
                  }
              }
          }
          return svgElement;
      }
      /**
       * Creates a SVG element.
       *
       * @param w SVG's width attribute
       * @param h SVG's height attribute
       */
      createSVGElement(w, h) {
          const svgElement = document.createElementNS(svgNs$1, 'svg');
          const width = w.toString();
          const height = h.toString();
          svgElement.setAttribute('height', height);
          svgElement.setAttribute('width', width);
          svgElement.setAttribute('viewBox', "0 0 " + width + " " + height);
          return svgElement;
      }
      /**
       * Creates a SVG rect element.
       *
       * @param x Element's x coordinate
       * @param y Element's y coordinate
       * @param w Element's width attribute
       * @param h Element's height attribute
       */
      createSvgRectElement(x, y, w, h) {
          const rect = document.createElementNS(svgNs$1, 'rect');
          rect.setAttribute('x', x.toString());
          rect.setAttribute('y', y.toString());
          rect.setAttribute('height', w.toString());
          rect.setAttribute('width', h.toString());
          rect.setAttribute('fill', '#000000');
          return rect;
      }
  }
  BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;

  exports.BarcodeFormat = BarcodeFormat$1;
  exports.BrowserAztecCodeReader = BrowserAztecCodeReader$1;
  exports.BrowserCodeReader = BrowserCodeReader$1;
  exports.BrowserCodeSvgWriter = BrowserCodeSvgWriter;
  exports.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader$1;
  exports.BrowserMultiFormatOneDReader = BrowserMultiFormatOneDReader;
  exports.BrowserMultiFormatReader = BrowserMultiFormatReader$1;
  exports.BrowserPDF417Reader = BrowserPDF417Reader$1;
  exports.BrowserQRCodeReader = BrowserQRCodeReader$1;
  exports.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
  exports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource$1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=zxing-browser.js.map
